<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python DSA Mastery</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-color: #3776ab; /* Python Blue */
            --secondary-color: #ffd343; /* Python Yellow */
            --accent-color: #ff6f61; /* A contrasting accent */
            --text-color-light: #2c3e50; /* Dark text on light background */
            --bg-color-light: #f8f9fa;
            --card-bg-light: #ffffff;
            --border-color-light: #e0e0e0;
            --header-bg-light: linear-gradient(135deg, var(--primary-color), #2c578f);


            --text-color-dark: #ecf0f1; /* Light text on dark background */
            --bg-color-dark: #2c3e50;
            --card-bg-dark: #34495e;
            --border-color-dark: #4a6572;
            --header-bg-dark: linear-gradient(135deg, #1e4872, #1a252f);

            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --font-sans: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }

        /* Global Resets and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px; /* Base font size */
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-sans);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body[data-theme="light"] {
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
        }

        body[data-theme="dark"] {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
        }

        /* Header Styles */
        .site-header {
            color: white;
            padding: 1.5rem 1rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            transition: background 0.3s ease;
        }
        body[data-theme="light"] .site-header {
            background: var(--header-bg-light);
        }
        body[data-theme="dark"] .site-header {
            background: var(--header-bg-dark);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .site-header h1 {
            font-size: clamp(1.5rem, 5vw, 2.2rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0; /* Remove default margin */
        }
        .site-header h1 i {
            color: var(--secondary-color);
            font-size: clamp(1.8rem, 6vw, 2.5rem);
        }
        body[data-theme="dark"] .site-header h1 i {
            color: var(--secondary-color); /* Keep yellow for Python logo */
        }


        .search-container {
            position: relative;
            display: flex;
            align-items: center;
            min-width: 250px;
            flex-grow: 1; /* Allow it to grow */
            max-width: 500px; /* But not too much */
        }

        #searchInput {
            width: 100%;
            padding: 0.75rem 1rem;
            padding-right: 2.5rem; /* Space for icon */
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        body[data-theme="light"] #searchInput {
            background-color: rgba(255,255,255,0.9);
            color: var(--text-color-light);
        }
        body[data-theme="dark"] #searchInput {
            background-color: rgba(255,255,255,0.1);
            color: var(--text-color-dark);
            border-color: var(--border-color-dark);
        }
        #searchInput:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(var(--secondary-color-rgb, 255, 211, 67), 0.5); /* Add RGB version for opacity */
        }
        body[data-theme="dark"] #searchInput:focus {
            box-shadow: 0 0 0 3px rgba(var(--secondary-color-rgb, 255, 211, 67), 0.4);
        }

        .search-icon {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem;
            pointer-events: none; /* So it doesn't interfere with input click */
        }
        body[data-theme="light"] .search-icon {
            color: var(--primary-color);
        }
        body[data-theme="dark"] .search-icon {
            color: var(--secondary-color);
        }


        .theme-btn {
            background: transparent;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            margin-left: 1rem; /* Space from search bar */
        }
        .theme-btn:hover {
            background-color: rgba(255,255,255,0.15);
            transform: scale(1.1);
        }
        body[data-theme="dark"] .theme-btn {
             border-color: var(--secondary-color);
             color: var(--secondary-color);
        }
        body[data-theme="dark"] .theme-btn:hover {
             background-color: rgba(var(--secondary-color-rgb, 255, 211, 67), 0.1);
        }


        /* Main Content Area */
        .dsa-container {
            max-width: 900px; /* Slightly narrower for better readability of single column */
            margin: 2rem auto;
            padding: 0 1rem;
        }

        /* DSA Category (Accordion Item) */
        .dsa-category {
            margin-bottom: 1.5rem;
            border-radius: var(--border-radius);
            overflow: hidden; /* Important for border-radius on children */
            transition: box-shadow 0.3s ease;
        }
        body[data-theme="light"] .dsa-category {
            background-color: var(--card-bg-light);
            border: 1px solid var(--border-color-light);
            box-shadow: var(--box-shadow);
        }
        body[data-theme="dark"] .dsa-category {
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-color-dark);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }


        .category-header {
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        body[data-theme="light"] .category-header {
            border-bottom: 1px solid var(--border-color-light);
        }
        body[data-theme="dark"] .category-header {
            border-bottom: 1px solid var(--border-color-dark);
        }
        .dsa-category.active .category-header { /* Style when active/open */
            /* background-color: #e9f5ff; Slightly different bg if needed */
        }
        body[data-theme="light"] .category-header:hover {
            background-color: #f1f3f5;
        }
        body[data-theme="dark"] .category-header:hover {
            background-color: #3e5669;
        }

        .category-title {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        body[data-theme="light"] .category-title {
            color: var(--primary-color);
        }
        body[data-theme="dark"] .category-title {
            color: var(--secondary-color);
        }
        .category-title .icon { /* For category-specific icon */
            font-size: 1.3rem;
        }

        .category-toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        .dsa-category.active .category-toggle-icon {
            transform: rotate(180deg);
        }

        .category-description {
            font-size: 0.9rem;
            padding: 0 1.5rem 0.5rem 1.5rem; /* Shown below title, before subtopics list if needed */
            opacity: 0.8;
        }
        body[data-theme="light"] .category-description {
             border-bottom: 1px solid var(--border-color-light);
             color: #555;
        }
         body[data-theme="dark"] .category-description {
             border-bottom: 1px solid var(--border-color-dark);
             color: #bdc3c7;
        }

        .sub-topics-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding: 0 1.5rem; /* No padding when collapsed */
        }
        .dsa-category.active .sub-topics-list {
            max-height: 1500px; /* Adjust if needed, large enough for content */
            padding: 1rem 1.5rem;
            /* border-top: 1px solid var(--border-color-light); /* if category-description is not used */
        }
        body[data-theme="dark"] .dsa-category.active .sub-topics-list {
            /* border-top-color: var(--border-color-dark); */
        }

        .sub-topic-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: calc(var(--border-radius) - 4px);
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            border-left: 3px solid transparent;
        }
        .sub-topic-item:last-child {
            margin-bottom: 0;
        }
        body[data-theme="light"] .sub-topic-item {
            background-color: #f8f9fa; /* Slightly different from card bg */
        }
        body[data-theme="dark"] .sub-topic-item {
            background-color: #4a6572; /* Slightly different from card bg */
        }

        .sub-topic-item:hover {
            transform: translateX(5px);
        }
        body[data-theme="light"] .sub-topic-item:hover {
            background-color: #e9ecef;
            border-left-color: var(--accent-color);
        }
        body[data-theme="dark"] .sub-topic-item:hover {
            background-color: #547285;
            border-left-color: var(--accent-color);
        }

        .sub-topic-title {
            font-size: 1.1rem;
            font-weight: 500;
        }

                /* --- Add these Modal Styles (or adapt from previous project) --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1050; /* Higher than header */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent body scroll when modal is open */
            outline: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent backdrop */
            animation: fadeInBackdrop 0.3s ease-out;
        }

        @keyframes fadeInBackdrop {
            from { opacity: 0; }
            to { opacity: 1; }
        }


        .modal-content {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 90%; /* Responsive width */
            max-width: 800px; /* Max width for larger screens */
            pointer-events: auto;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0,0,0,.5);
            margin: 1.75rem auto; /* Centered with space */
            max-height: calc(100vh - 3.5rem); /* Full height minus margins */
            animation: slideInModal 0.3s ease-out;
        }
        body[data-theme="light"] .modal-content {
            background-color: var(--card-bg-light);
            border: 1px solid var(--border-color-light);
        }
        body[data-theme="dark"] .modal-content {
            background-color: var(--card-bg-dark);
            border: 1px solid var(--border-color-dark);
        }

        @keyframes slideInModal {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }


        .modal-header {
            display: flex;
            align-items: flex-start; /* Align items to the top */
            justify-content: space-between;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid;
        }
        body[data-theme="light"] .modal-header { border-bottom-color: var(--border-color-light); }
        body[data-theme="dark"] .modal-header { border-bottom-color: var(--border-color-dark); }


        .modal-title {
            margin-bottom: 0;
            line-height: 1.5;
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        body[data-theme="light"] .modal-title { color: var(--primary-color); }
        body[data-theme="dark"] .modal-title { color: var(--secondary-color); }


        .close-button {
            font-size: 1.8rem;
            font-weight: 700;
            line-height: 1;
            opacity: 0.7;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.25rem 0.5rem; /* Easier to click */
            margin: -0.5rem -0.5rem -0.5rem auto; /* Adjust positioning slightly */
        }
        body[data-theme="light"] .close-button { color: var(--text-color-light); }
        body[data-theme="dark"] .close-button { color: var(--text-color-dark); }
        .close-button:hover {
            opacity: 1;
        }

        .modal-body {
            position: relative;
            flex: 1 1 auto; /* Allows body to grow and fill space */
            padding: 1.5rem;
            overflow-y: auto; /* IMPORTANT: This makes the modal body scrollable */
        }

        /* Styling for content within modal-body (same as previous .topic-detail-panel styles) */
        .modal-body h4 { /* For concept heading */
            font-size: 1.3rem;
            margin-top: 0; /* No top margin for first h4 in modal */
            margin-bottom: 0.75rem;
        }
        body[data-theme="light"] .modal-body h4 { color: var(--primary-color); }
        body[data-theme="dark"] .modal-body h4 { color: var(--secondary-color); }

        .modal-body p {
            margin-bottom: 1rem;
        }
        .modal-body .operations-list .operation {
            margin-bottom: 1.5rem;
        }
        .modal-body .operations-list .operation h5 { /* For operation name */
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        body[data-theme="light"] .modal-body .operations-list .operation h5 { color: var(--text-color-light); }
        body[data-theme="dark"] .modal-body .operations-list .operation h5 { color: var(--text-color-dark); }

        .modal-body .operations-list .operation .op-description,
        .modal-body .operations-list .operation .op-complexity {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }
        .modal-body .op-complexity code { /* Consistent code styling */
            font-size: 0.85rem;
            padding: 2px 4px;
            border-radius: 3px;
        }
        body[data-theme="light"] .modal-body .op-complexity code { background-color: #e0e0e0;}
        body[data-theme="dark"] .modal-body .op-complexity code { background-color: #404854;}

        /* Remove or comment out .topic-detail-panel styles if they exist */
        /*
        .topic-detail-panel {
            display: none; /* No longer used
        }
        */



        .operations-list .operation {
            margin-bottom: 1.5rem;
        }
        .operations-list .operation h5 { /* For operation name */
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        body[data-theme="light"] .operations-list .operation h5 { color: var(--text-color-light); }
        body[data-theme="dark"] .operations-list .operation h5 { color: var(--text-color-dark); }

        .operations-list .operation .op-description,
        .operations-list .operation .op-complexity {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }
        .op-complexity code {
            font-size: 0.85rem;
        }

        /* Code block styling (basic, can be enhanced by Prism.js) */
        pre {
            padding: 1em;
            margin: .5em 0;
            overflow: auto;
            border-radius: var(--border-radius);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
            tab-size: 4;
        }
        code {
            font-family: var(--font-mono);
        }
        body[data-theme="light"] pre {
            background: #f0f0f0; /* Light background for code */
            color: #333;
            border: 1px solid #ddd;
        }
        body[data-theme="dark"] pre {
            background: #282c34; /* Dark background for code (Atom One Dark style) */
            color: #abb2bf;
            border: 1px solid #3a404a;
        }
        body[data-theme="light"] .op-complexity code { background-color: #e0e0e0; padding: 2px 4px; border-radius: 3px;}
        body[data-theme="dark"] .op-complexity code { background-color: #404854; padding: 2px 4px; border-radius: 3px;}


        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }


        /* Footer Styles */
        .site-footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 3rem;
            font-size: 0.9rem;
        }
        body[data-theme="light"] .site-footer {
            background-color: #e9ecef;
            color: #6c757d;
            border-top: 1px solid var(--border-color-light);
        }
        body[data-theme="dark"] .site-footer {
            background-color: #212e3a;
            color: var(--dark-gray);
            border-top: 1px solid var(--border-color-dark);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
            .site-header h1 {
                margin-bottom: 0.5rem;
            }
            .search-container {
                width: 100%; /* Full width on mobile */
                min-width: unset;
                margin-bottom: 0.5rem;
            }
            .theme-btn {
                position: absolute; /* Keep it top right relative to header */
                top: 1.5rem;
                right: 1rem;
            }
            .dsa-container {
                margin-top: 1.5rem;
            }
            .category-title {
                font-size: 1.3rem;
            }
            .sub-topic-title {
                font-size: 1rem;
            }
        }

    </style>
</head>
<body data-theme="light"> 
    <header class="site-header">
        <div class="header-content">
            <h1><i class="fab fa-python"></i> Python DSA Mastery</h1>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Search topics (e.g., BST, QuickSort)...">
                <i class="fas fa-search search-icon"></i>
            </div>
        </div>
        <button id="themeSwitcher" class="theme-btn" title="Toggle theme"><i class="fas fa-moon"></i></button>
    </header>

    <main class="dsa-container" id="dsaContainer">
        <!-- DSA Categories and Topics will be dynamically inserted here -->
    </main>

    <footer class="site-footer">
        <p>© <span id="currentYear"></span> Python DSA Mastery. Your go-to DSA resource.</p>
    </footer>
        <!-- ... (after your footer) ... -->

    <div id="dsaTopicModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-book-open"></i> <span id="modalTopicTitle">Topic Details</span></h2>
                <span class="close-button" id="closeModalBtn">×</span>
            </div>
            <div id="modalTopicBody" class="modal-body">
                <!-- Detailed DSA content will be injected here -->
            </div>
        </div>
    </div>

    <!-- Prism.js JS (if used) would go here before our script -->
    <script>
        // JavaScript contentData and rendering logic will go here
    </script>
</body>
</html>
<script>
        // --- DSA Topics Data ---
        const dsaTopics = [
            // --- CATEGORY: Core Python Data Structures ---
            {
                category: "Core Python Data Structures",
                categoryId: "core_python_ds",
                icon: "fab fa-python",
                description: "Understanding and utilizing Python's powerful built-in data structures and common techniques for arrays and strings.",
                subTopics: [
                    {
                        id: "python_lists",
                        title: "Lists (Dynamic Arrays)",
                        concept: "Python's `list` is a versatile, mutable, ordered sequence type that acts as a dynamic array. It can store heterogeneous data types and automatically resizes. Understanding its time complexities for various operations is key.",
                        operations: [
                            { name: "Initialization", description: "Creating empty or populated lists.", code: `empty_list = []\nnumbers = [1, 2, 3, 5, 8]\nmixed_list = [1, "hello", 3.14, True]`, complexity: "O(k) where k is # of elements" },
                            { name: "Accessing & Slicing", description: "Using index (0-based) and slicing to retrieve elements or sub-lists.", code: `my_list = ['a', 'b', 'c', 'd', 'e']\nfirst_element = my_list[0]  # 'a'\nlast_element = my_list[-1] # 'e'\nsub_list = my_list[1:4] # ['b', 'c', 'd']\nreversed_list = my_list[::-1] # ['e', 'd', 'c', 'b', 'a']`, complexity: "Access: O(1), Slice: O(k) where k is slice size" },
                            { name: "Append (add to end)", description: "Adds an element to the end of the list.", code: `my_list = [1, 2, 3]\nmy_list.append(4)\n# my_list is now [1, 2, 3, 4]`, complexity: "O(1) amortized" },
                            { name: "Insert (at index)", description: "Inserts an element at a specific position.", code: `my_list = [1, 2, 4]\nmy_list.insert(2, 3)\n# my_list is now [1, 2, 3, 4]`, complexity: "O(n)" },
                            { name: "Extend (append elements from iterable)", description: "Appends all items from an iterable to the list.", code: `list1 = [1, 2]\nlist2 = [3, 4]\nlist1.extend(list2)\n# list1 is now [1, 2, 3, 4]`, complexity: "O(k) where k is length of iterable" },
                            { name: "Remove (by value)", description: "Removes the first occurrence of a specific value.", code: `my_list = ['a', 'b', 'c', 'b']\nmy_list.remove('b')\n# my_list is now ['a', 'c', 'b']`, complexity: "O(n)" },
                            { name: "Pop (by index or last)", description: "Removes and returns an element at a given index (or the last item if index is not specified).", code: `my_list = [10, 20, 30, 40]\nlast_item = my_list.pop() # 40, my_list is [10, 20, 30]\nitem_at_index1 = my_list.pop(1) # 20, my_list is [10, 30]`, complexity: "pop(): O(1), pop(i): O(n)" },
                            { name: "Delete (del keyword)", description: "Removes items by index, slice, or the entire list.", code: `my_list = [1, 2, 3, 4, 5]\ndel my_list[1] # [1, 3, 4, 5]\ndel my_list[1:3] # [1, 5]\n# del my_list # Deletes the list entirely`, complexity: "O(n) for index/slice" },
                            { name: "Index (find first occurrence)", description: "Returns the index of the first occurrence of a value.", code: `my_list = ['x', 'y', 'z', 'y']\nindex_y = my_list.index('y') # 1`, complexity: "O(n)" },
                            { name: "Count (occurrences of value)", description: "Returns the number of times a value appears in the list.", code: `my_list = [1, 2, 2, 3, 2]\ncount_2 = my_list.count(2) # 3`, complexity: "O(n)" },
                            { name: "Sort (in-place, with key)", description: "Sorts the list in ascending order by default. The `key` argument can specify a function to be called on each list element prior to making comparisons.", code: `my_list = [3, 1, 4, 1, 5, 9, 2]\nmy_list.sort()\n# my_list is [1, 1, 2, 3, 4, 5, 9]\nmy_list.sort(reverse=True)\n# my_list is [9, 5, 4, 3, 2, 1, 1]\n\nwords = ["banana", "Apple", "cherry"]\nwords.sort(key=str.lower) # Case-insensitive sort\n# words is ['Apple', 'banana', 'cherry']`, complexity: "O(n log n) - Timsort" },
                            { name: "Sorted (returns new sorted list, with key)", description: "Returns a new list containing all items from the iterable in ascending order. Also accepts a `key` argument.", code: `my_list = [3, 1, 4]\nnew_sorted_list = sorted(my_list)\n# new_sorted_list is [1, 3, 4], my_list is unchanged\n\nstudents = [('Alice', 25), ('Bob', 20), ('Charlie', 30)]\nsorted_students_by_age = sorted(students, key=lambda student: student[1])\n# [('Bob', 20), ('Alice', 25), ('Charlie', 30)]`, complexity: "O(n log n)" },
                            { name: "Reverse (in-place)", description: "Reverses the elements of the list in place.", code: `my_list = [1, 2, 3]\nmy_list.reverse()\n# my_list is [3, 2, 1]`, complexity: "O(n)" },
                            { name: "Copy (shallow copy)", description: "Returns a shallow copy of the list. Changes to mutable elements within the copied list will affect the original.", code: `original = [1, [2,3]]\ncopied_list = original.copy()\nshallow_copy_slice = original[:]`, complexity: "O(n)" },
                            { name: "Length (len())", description: "Gets the number of items in the list.", code: `my_list = [10, 20, 30]\nlength = len(my_list) # length is 3`, complexity: "O(1)" },
                            { name: "Membership (in, not in)", description: "Checks if an item exists in the list.", code: `my_list = [1, 2, 3]\nis_present = 2 in my_list # True\nis_absent = 4 not in my_list # True`, complexity: "O(n)" },
                            { name: "Concatenation (+)", description: "Combines two lists.", code: `list1 = [1, 2]\nlist2 = [3, 4]\ncombined = list1 + list2 # [1, 2, 3, 4]`, complexity: "O(n+k)" },
                            { name: "Repetition (*)", description: "Repeats list elements.", code: `my_list = [1, 2] * 3 # [1, 2, 1, 2, 1, 2]`, complexity: "O(nk)" },
                            { name: "Traversal", description: "Iterating through elements of a list.", code: `my_list = ["apple", "banana", "cherry"]\nfor item in my_list:\n    print(item)\n\nfor i in range(len(my_list)):\n    print(my_list[i])`, complexity: "O(n)"}
                        ]
                    },
                    {
                        id: "python_tuples",
                        title: "Tuples",
                        concept: "Tuples are ordered, immutable sequences of items. They are often used for fixed collections of items whose order is important and content should not change. Useful as dictionary keys (if they contain hashable types).",
                        operations: [
                            { name: "Initialization", description: "Creating empty or populated tuples.", code: `empty_tuple = ()\npoint = (10, 20)\nperson = 'Alice', 30, 'Engineer' # Parentheses optional for packing\nsingle_item_tuple = (1,) # Comma is essential`, complexity: "O(k)" },
                            { name: "Accessing & Slicing", description: "Similar to lists, using index and slicing.", code: `my_tuple = (1, 2, 3, 4)\nfirst = my_tuple[0] # 1\nsub_tuple = my_tuple[1:3] # (2, 3)`, complexity: "Access: O(1), Slice: O(k)" },
                            { name: "Length (len())", description: "Gets the number of items.", code: `my_tuple = (1, 2)\nlength = len(my_tuple) # 2`, complexity: "O(1)" },
                            { name: "Membership (in, not in)", description: "Checks if an item exists.", code: `my_tuple = (1, 2, 3)\nexists = 2 in my_tuple # True`, complexity: "O(n)" },
                            { name: "Concatenation (+)", description: "Combines two tuples.", code: `tuple1 = (1,2)\ntuple2 = (3,4)\ncombined = tuple1 + tuple2 # (1,2,3,4)`, complexity: "O(n+k)" },
                            { name: "Repetition (*)", description: "Repeats tuple elements.", code: `my_tuple = ('hi',) * 3 # ('hi', 'hi', 'hi')`, complexity: "O(nk)" },
                            { name: "Iteration", description: "Looping through tuple elements.", code: `my_tuple = ('a', 'b')\nfor item in my_tuple: print(item)`, complexity: "O(n)" },
                            { name: "Count", description: "Count occurrences of a value.", code: `my_tuple = (1,2,2,3)\nc = my_tuple.count(2) # 2`, complexity: "O(n)"},
                            { name: "Index", description: "Find index of first occurrence.", code: `my_tuple = (1,2,3,2)\ni = my_tuple.index(2) # 1`, complexity: "O(n)"},
                            { name: "Named Tuples (collections.namedtuple)", description: "Tuples with named fields for better readability.", code: `from collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np1 = Point(10, 20)\n# p1.x is 10, p1.y is 20, p1[0] is 10`, complexity: "Access by name/index: O(1)"},
                            { name: "Unpacking", description: "Assigning tuple elements to individual variables.", code: `point = (100, 200)\nx, y = point # x=100, y=200`, complexity: "O(k)"}
                        ]
                    },
                    {
                        id: "python_dictionaries",
                        title: "Dictionaries (Hash Maps)",
                        concept: "Dictionaries are unordered (ordered in Python 3.7+) collections of key-value pairs. Keys must be unique and hashable. They provide efficient O(1) average time complexity for lookups, insertions, and deletions.",
                        operations: [
                            { name: "Initialization", description: "Creating empty or populated dictionaries.", code: `empty_dict = {}\nperson = {'name': 'Alice', 'age': 30}\nconfig = dict(host='localhost', port=8080)`, complexity: "O(k) for k items" },
                            { name: "Accessing Values (by key)", description: "Using keys to retrieve values. Raises KeyError if key not found.", code: `person = {'name': 'Alice', 'age': 30}\nname = person['name'] # 'Alice'`, complexity: "O(1) average" },
                            { name: "Get (safe access)", description: "Safely retrieves a value, returns default if key not found.", code: `person = {'name': 'Alice'}\ncountry = person.get('country', 'Unknown') # 'Unknown'`, complexity: "O(1) average" },
                            { name: "Adding/Updating Key-Value Pairs", description: "Assigning a value to a key.", code: `person = {}\nperson['city'] = 'New York'\nperson['city'] = 'London' # Updates existing key`, complexity: "O(1) average" },
                            { name: "Deleting Key-Value Pairs (pop, del)", description: "Removes items. `pop()` returns the value, `del` is a statement.", code: `person = {'name':'Bob', 'age':25, 'city':'Paris'}\nage = person.pop('age') # 25, person is {'name':'Bob', 'city':'Paris'}\ndel person['city'] # person is {'name':'Bob'}`, complexity: "O(1) average" },
                            { name: "Length (len())", description: "Number of key-value pairs.", code: `person = {'name':'Eve', 'id':3}\nsize = len(person) # 2`, complexity: "O(1)" },
                            { name: "Membership (in, not in - checks keys)", description: "Checks if a key exists.", code: `person = {'name':'Carl'}\nhas_name = 'name' in person # True\nhas_age = 'age' in person # False`, complexity: "O(1) average" },
                            { name: "Iterating (keys, values, items)", description: "Looping through dictionary components.", code: `person = {'a':1, 'b':2}\nfor key in person: print(key) # or person.keys()\nfor value in person.values(): print(value)\nfor key, value in person.items(): print(key, value)`, complexity: "O(n)" },
                            { name: "Update (merge dictionaries)", description: "Merges another dictionary or iterable of key-value pairs.", code: `dict1 = {'a':1}\ndict2 = {'b':2, 'a':10}\ndict1.update(dict2) # dict1 is {'a':10, 'b':2}`, complexity: "O(k) where k is size of dict2" },
                            { name: "Clear (remove all items)", description: "Empties the dictionary.", code: `my_dict = {'x':1}\nmy_dict.clear()\n# my_dict is {}`, complexity: "O(1)" },
                            { name: "Copy (shallow copy)", description: "Returns a shallow copy.", code: `original = {'data':[1,2]}\ncopied_dict = original.copy()`, complexity: "O(n)"},
                            { name: "setdefault", description: "Returns value if key exists, otherwise inserts key with default value and returns it.", code: `my_dict = {'a':1}\nval_a = my_dict.setdefault('a', 0) # 1\nval_b = my_dict.setdefault('b', 0) # 0, my_dict is {'a':1, 'b':0}`, complexity: "O(1) average"},
                            { name: "Comprehensions", description: "Concise way to create dictionaries.", code: `squares = {x: x*x for x in range(5)}\n# squares is {0:0, 1:1, 2:4, 3:9, 4:16}`, complexity: "O(n)"},
                            { name: "Frequency Counter Application", description: "Counting occurrences of items in an iterable.", code: `text = "hello world"\nfreq = {}\nfor char in text:\n    freq[char] = freq.get(char, 0) + 1\n# freq is {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}`, complexity: "O(N) where N is length of text"}
                        ]
                    },
                    {
                        id: "python_sets",
                        title: "Sets",
                        concept: "Sets are unordered collections of unique, hashable items. They are mutable. Primarily used for membership testing, removing duplicates, and mathematical set operations (union, intersection, difference, symmetric difference).",
                        operations: [
                            { name: "Initialization", description: "Creating empty or populated sets.", code: `empty_set = set()\nnumbers = {1, 2, 3, 2, 1} # numbers is {1, 2, 3}\nletters = set('hello') # letters is {'h', 'e', 'l', 'o'}`, complexity: "O(k) for k items" },
                            { name: "Add (single element)", description: "Adds an element. Does nothing if already present.", code: `my_set = {1, 2}\nmy_set.add(3)\nmy_set.add(1)\n# my_set is {1, 2, 3}`, complexity: "O(1) average" },
                            { name: "Update (multiple elements from iterable)", description: "Adds elements from an iterable.", code: `my_set = {1}\nmy_set.update([2,3], {3,4})\n# my_set is {1, 2, 3, 4}`, complexity: "O(k) for k new items" },
                            { name: "Remove (raises KeyError if not found)", description: "Removes an element. Raises KeyError if not present.", code: `my_set = {1, 2, 3}\nmy_set.remove(2)\n# my_set is {1, 3}`, complexity: "O(1) average" },
                            { name: "Discard (no error if not found)", description: "Removes an element if present.", code: `my_set = {1, 2}\nmy_set.discard(3)\nmy_set.discard(1)\n# my_set is {2}`, complexity: "O(1) average" },
                            { name: "Pop (removes and returns arbitrary element)", description: "Removes and returns an arbitrary element. Raises KeyError if empty.", code: `my_set = {1,2,3}\nitem = my_set.pop() # item could be 1, 2 or 3`, complexity: "O(1) average" },
                            { name: "Length (len())", description: "Number of unique elements.", code: `my_set = {1,1,2}\nsize = len(my_set) # 2`, complexity: "O(1)" },
                            { name: "Membership (in, not in)", description: "Efficiently checks if an element exists.", code: `my_set = {1,2,3}\nexists = 2 in my_set # True`, complexity: "O(1) average" },
                            { name: "Iteration", description: "Looping through set elements (order not guaranteed).", code: `my_set = {3,1,2}\nfor item in my_set: print(item)`, complexity: "O(n)" },
                            { name: "Union (| or .union())", description: "Returns a new set with elements from both sets.", code: `s1 = {1,2}; s2 = {2,3}\nunion_set = s1 | s2 \n# union_set = s1.union(s2) # {1,2,3}`, complexity: "O(len(s1)+len(s2))" },
                            { name: "Intersection (& or .intersection())", description: "Returns a new set with common elements.", code: `s1 = {1,2,3}; s2 = {2,3,4}\nintersect_set = s1 & s2\n# intersect_set is {2,3}`, complexity: "O(min(len(s1),len(s2)))" },
                            { name: "Difference (- or .difference())", description: "Returns a new set with elements in the first set but not in the second.", code: `s1 = {1,2,3}; s2 = {2,3,4}\ndiff_set = s1 - s2 # {1}`, complexity: "O(len(s1))" },
                            { name: "Symmetric Difference (^ or .symmetric_difference())", description: "Returns a new set with elements in either set, but not both.", code: `s1 = {1,2,3}; s2 = {2,3,4}\nsym_diff_set = s1 ^ s2 # {1,4}`, complexity: "O(len(s1)+len(s2))" },
                            { name: "Subset/Superset Check (<=, >=, .issubset(), .issuperset())", description: "Checks relationships between sets.", code: `s1 = {1,2}; s2 = {1,2,3}\nis_subset = s1 <= s2 # True\nis_superset = s2.issuperset(s1) # True`, complexity: "O(len(s1)) for subset check" },
                            { name: "Clear (remove all items)", description: "Empties the set.", code: `my_set = {1,2}\nmy_set.clear()\n# my_set is set()`, complexity: "O(1)"},
                            { name: "Copy (shallow copy)", description: "Returns a shallow copy.", code: `original = {1,2}\ncopied_set = original.copy()`, complexity: "O(n)"}
                        ]
                    },
                    {
                        id: "python_frozensets",
                        title: "Frozensets",
                        concept: "Frozensets are immutable versions of sets. Once created, their elements cannot be changed. Because they are immutable and hashable, they can be used as dictionary keys or elements of other sets.",
                        operations: [
                             { name: "Initialization", description: "Creating frozensets.", code: `fs = frozenset([1, 2, 3, 2])\n# fs is frozenset({1, 2, 3})`, complexity: "O(k)"},
                             { name: "Set Operations", description: "Supports union, intersection, difference, etc., like regular sets, but always returns a new frozenset (or set if combined with a set).", code: `fs1 = frozenset([1,2])\nfs2 = frozenset([2,3])\nunion_fs = fs1.union(fs2) # frozenset({1,2,3})`, complexity: "Varies per operation"},
                             { name: "No Mutating Operations", description: "Methods like add(), remove(), update(), pop() are not available.", code: `fs = frozenset([1,2])\n# fs.add(3) # AttributeError: 'frozenset' object has no attribute 'add'`, complexity: "-"}
                        ]
                    },
                     {
                        id: "python_strings",
                        title: "Strings",
                        concept: "Strings in Python are immutable sequences of Unicode characters. They support many sequence operations similar to lists and tuples, along with a rich set of string-specific methods for manipulation and searching.",
                        operations: [
                            { name: "Initialization & Literals", description: "Creating strings using single, double, or triple quotes.", code: `s1 = 'hello'\ns2 = "world"\ns3 = """multi\nline\nstring"""\ns4 = str(123) # Converting other types to string`, complexity: "O(k)"},
                            { name: "Concatenation & Repetition", description: "Joining strings using `+` and repeating them using `*`.", code: `greet = "Hello" + " " + "World" # "Hello World"\npattern = "-" * 10 # "----------"`, complexity: "Concatenation: O(n+k), Repetition: O(nk)"},
                            { name: "Indexing & Slicing", description: "Accessing individual characters and substrings.", code: `s = "Python"\nfirst_char = s[0] # 'P'\nlast_char = s[-1] # 'n'\nsubstring = s[1:4] # "yth" (from index 1 up to, but not including, 4)\nreverse_s = s[::-1] # "nohtyP"`, complexity: "Index: O(1), Slice: O(k)"},
                            { name: "Length (len())", description: "Returns the number of characters in the string.", code: `s = "abc"\nlength = len(s) # 3`, complexity: "O(1)"},
                            { name: "Iteration", description: "Looping through characters in a string.", code: `for char in "text":\n    print(char)`, complexity: "O(n)"},
                            { name: "Membership (in, not in)", description: "Checking if a character or substring exists within a string.", code: `is_substring = "yth" in "Python" # True\nnot_present = "abc" not in "Python" # True`, complexity: "O(nk) in general, but often optimized for char in string"},
                            { name: "Split (str.split())", description: "Splits the string at a specified separator (default is whitespace) and returns a list of substrings.", code: `sentence = "hello world example"\nwords = sentence.split() # ['hello', 'world', 'example']\ncsv_data = "apple,banana,cherry"\nitems = csv_data.split(',') # ['apple', 'banana', 'cherry']`, complexity: "O(n)"},
                            { name: "Join (separator.join(iterable))", description: "Joins the elements of an iterable (e.g., list of strings) into a single string, with the separator string inserted between elements.", code: `words_list = ['Python', 'is', 'fun']\njoined_sentence = " ".join(words_list) # "Python is fun"`, complexity: "O(N) where N is total length of strings"},
                            { name: "Strip (str.strip(), lstrip(), rstrip())", description: "Removes leading/trailing whitespace (or specified characters).", code: `s = "  Hello Python!  "\n_s_stripped = s.strip() # "Hello Python!"\ns_lstripped = s.lstrip() # "Hello Python!  "\ns_rstipped = s.rstrip() # "  Hello Python!"\ncustom_strip = "---test---".strip('-') # "test"`, complexity: "O(n)"},
                            { name: "Find/Index (str.find(), str.index())", description: "`find()` returns the starting index of the first occurrence of a substring (or -1 if not found). `index()` is similar but raises ValueError if not found.", code: `s = "hello world"\npos_o = s.find('o') # 4\npos_not_found = s.find('xyz') # -1\n# index_xyz = s.index('xyz') # Raises ValueError`, complexity: "O(nk)"},
                            { name: "Replace (str.replace())", description: "Returns a new string where occurrences of a substring are replaced with another substring.", code: `s = "one two one"\nnew_s = s.replace("one", "three") # "three two three"\nlimited_replace = s.replace("one", "three", 1) # "three two one" (replaces only first occurrence)`, complexity: "O(n)"},
                            { name: "Case Conversion (upper(), lower(), capitalize(), title(), swapcase())", description: "Methods for changing the case of characters.", code: `s = "hELLo wORLd"\ns_upper = s.upper() # "HELLO WORLD"\ns_lower = s.lower() # "hello world"\ns_cap = "first".capitalize() # "First"\ns_title = "hello world".title() # "Hello World"\ns_swap = "TeSt".swapcase() # "tEsT"`, complexity: "O(n)"},
                            { name: "Check Methods (startswith(), endswith(), isalpha(), isdigit(), isalnum(), isspace(), islower(), isupper())", description: "Boolean methods to check string properties.", code: `s = "Python3"\ns.startswith("Py") # True\ns.endswith("on") # True\n"abc".isalpha() # True\n"123".isdigit() # True\ns.isalnum() # True`, complexity: "O(k) for startswith/endswith (k=prefix/suffix len), O(n) for others"},
                            { name: "Format (str.format(), f-strings)", description: "Formatting strings with variable content.", code: `name = "Alice"; age = 30\nformatted_s1 = "Name: {}, Age: {}".format(name, age)\nformatted_s2 = f"Name: {name}, Age: {age}" # f-string (Python 3.6+)\n# Both result in "Name: Alice, Age: 30"`, complexity: "O(N) where N is length of final string"},
                            { name: "String Reversal Application", description: "Reversing a string.", code: `s = "madam"\nreversed_s = s[::-1] # "madam"\n# Palindrome check: s == s[::-1]`, complexity: "O(n)"},
                            { name: "Anagram Check Application", description: "Checking if two strings are anagrams (rearrangements of each other).", code: `def is_anagram(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    return sorted(s1.lower()) == sorted(s2.lower())\n# is_anagram("listen", "silent") # True\n# Can also use Counter: from collections import Counter; Counter(s1.lower()) == Counter(s2.lower())`, complexity: "Sort: O(N log N), Counter: O(N)"}
                        ]
                    },
                    {
                        id: "collections_module_ds",
                        title: "collections Module Data Structures",
                        concept: "The `collections` module provides specialized container datatypes beyond Python's built-in general purpose containers, offering specific functionalities and performance characteristics for certain tasks.",
                        operations: [
                            { name: "collections.deque", description: "Double-ended queue supporting efficient appends and pops from both ends (O(1)). Useful for implementing queues, stacks, or keeping a sliding window of recent items.", code: `from collections import deque\nd = deque([1,2,3], maxlen=5) # Optional maxlen\nd.appendleft(0) # deque([0, 1, 2, 3])\nd.append(4)     # deque([0, 1, 2, 3, 4])\nleft_item = d.popleft() # 0, d is deque([1, 2, 3, 4])\nright_item = d.pop()    # 4, d is deque([1, 2, 3])\nd.rotate(1) # deque([3,1,2]) (rotates elements to the right)`, complexity: "Append/Pop from ends: O(1), rotate: O(k)"},
                            { name: "collections.Counter", description: "A dict subclass for counting hashable objects. Elements are stored as dictionary keys and their counts are stored as dictionary values.", code: `from collections import Counter\nc = Counter(['a','b','a','c','b','a', 'd'])\n# c is Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})\nprint(c['a']) # 3\nprint(list(c.elements())) # ['a', 'a', 'a', 'b', 'b', 'c', 'd']\nprint(c.most_common(2)) # [('a', 3), ('b', 2)]\nc.update(['a','e']) # Counter({'a': 4, 'b': 2, 'c': 1, 'd': 1, 'e':1})`, complexity: "Init: O(N), Access/Update: O(1) avg, most_common: O(k log k)"},
                            { name: "collections.defaultdict", description: "A dict subclass that calls a factory function (default_factory) to supply missing values when a key is accessed and not found, instead of raising a KeyError.", code: `from collections import defaultdict\ndd_list = defaultdict(list) # Default factory is list()\ndd_list['fruits'].append('apple')\n# dd_list is defaultdict(<class 'list'>, {'fruits': ['apple']})\n\ndd_int = defaultdict(int) # Default factory is int(), returns 0\nprint(dd_int['count']) # 0, dd_int is defaultdict(<class 'int'>, {'count':0})`, complexity: "Access/Update: O(1) avg (including factory call for new key)"},
                            { name: "collections.OrderedDict", description: "A dict subclass that remembers the order in which entries were added. (Less critical since Python 3.7+, as native `dict` also maintains insertion order). Still useful for explicit ordering semantics or compatibility.", code: `from collections import OrderedDict\nod = OrderedDict()\nod['first'] = 1\nod['second'] = 2\nod['third'] = 3\n# Iteration preserves insertion order: first, second, third\nod.move_to_end('first') # Moves 'first' to the end`, complexity: "Similar to dict, move_to_end: O(1)"},
                            { name: "collections.namedtuple", description: "Factory function for creating tuple subclasses with named fields, providing more readable and self-documenting code when accessing tuple elements.", code: `from collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y', 'z'])\np = Point(10, y=20, z=30)\nprint(p.x, p[1], p.z) # 10 20 30\n# Can be converted to dict: p._asdict()`, complexity: "Access by name/index: O(1)"}
                        ]
                    },
                    {
                        id: "adv_array_string_techniques",
                        title: "Array/String Techniques & Patterns",
                        concept: "Common algorithmic patterns used to solve problems involving arrays and strings efficiently. These techniques often reduce time complexity significantly.",
                        operations: [
                            { name: "Prefix Sum / Suffix Sum", description: "Precomputing sums (or other aggregates) of prefixes/suffixes to answer range queries in O(1). Useful for problems like 'find sum of subarray from index i to j'.", code: `nums = [1, 2, 3, 4, 5]\nprefix_sum = [0] * (len(nums) + 1)\nfor i in range(len(nums)):\n    prefix_sum[i+1] = prefix_sum[i] + nums[i]\n# prefix_sum is [0, 1, 3, 6, 10, 15]\n# To get sum(nums[j:k]): prefix_sum[k] - prefix_sum[j] (adjust indices based on problem)`, complexity: "Precomputation: O(n), Query: O(1)" },
                            { name: "Two Pointers Technique", description: "Using two pointers (indices) to traverse an array or string, often from opposite ends or one fast and one slow, to find pairs, subarrays, or check properties.", code: `def find_pair_sum_sorted(arr, target_sum):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target_sum:\n            return (arr[left], arr[right])\n        elif current_sum < target_sum:\n            left += 1\n        else:\n            right -= 1\n    return None\n# find_pair_sum_sorted([1,2,3,4,6], 6) -> (2,4)`, complexity: "O(n) for sorted array" },
                            { name: "Sliding Window Technique", description: "Maintaining a 'window' (a subarray or substring) that slides through the data. Useful for problems on contiguous sections, like finding max/min sum subarray of size k, or longest substring with certain properties.", code: `def max_sum_subarray_fixed_k(arr, k):\n    if k == 0 or k > len(arr): return 0\n    max_s = float('-inf')\n    current_window_sum = sum(arr[:k])\n    max_s = current_window_sum\n    for i in range(k, len(arr)):\n        current_window_sum = current_window_sum - arr[i-k] + arr[i]\n        max_s = max(max_s, current_window_sum)\n    return max_s`, complexity: "O(n)" },
                            { name: "Kadane's Algorithm", description: "Efficiently finds the maximum sum of a contiguous subarray within a one-dimensional array (which can contain positive and negative numbers).", code: `def kadane_max_subarray_sum(arr):\n    if not arr: return 0\n    max_so_far = arr[0]\n    current_max = arr[0]\n    for i in range(1, len(arr)):\n        current_max = max(arr[i], current_max + arr[i])\n        max_so_far = max(max_so_far, current_max)\n    return max_so_far\n# kadane_max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) -> 6 (from [4,-1,2,1])`, complexity: "O(n)" },
                            { name: "Array Rotation", description: "Rotating elements of an array by k positions to the left or right. Can be done in-place or with extra space.", code: `def rotate_array_right(arr, k):\n    n = len(arr)\n    if n == 0: return arr\n    k = k % n # Handle k larger than n\n    # Pythonic slicing (O(n) space)\n    # return arr[-k:] + arr[:-k]\n    # In-place using reverse (O(1) space)\n    def reverse(sub_arr, start, end):\n        while start < end:\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1; end -= 1\n    reverse(arr, 0, n - 1)\n    reverse(arr, 0, k - 1)\n    reverse(arr, k, n - 1)\n    return arr # arr is modified in-place`, complexity: "Slicing: O(n) time & space. Reverse: O(n) time, O(1) space" }
                        ]
                    }
                ]
            },
            // --- CATEGORY: Abstract Data Types (ADT) & Custom Implementations ---
            {
                category: "Fundamental Data Structures (Implementations)",
                categoryId: "fundamental_ds_impl",
                icon: "fas fa-cogs",
                description: "Implementing classic data structures from scratch to understand their underlying mechanics, even if Python offers built-in alternatives or modules.",
                subTopics: [
                    {
                        id: "linked_lists_singly",
                        title: "Singly Linked List",
                        concept: "A linear data structure where elements (nodes) are not stored at contiguous memory locations. Each node points to the next node. Operations like insertion/deletion at ends can be efficient, but access requires traversal.",
                        operations: [
                             { name: "Node Class", description: "Defines the structure of a single node in the list.", code: `class Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None`, complexity: "-" },
                             { name: "SinglyLinkedList Class (Initialization & Display)", description: "Basic class structure for the linked list, starting with an empty head. Includes a display method.", code: `class SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def display(self):\n        elements = []\n        current_node = self.head\n        while current_node:\n            elements.append(str(current_node.data)) # Ensure data is string for join\n            current_node = current_node.next\n        print(" -> ".join(elements) if elements else "List is empty")`, complexity: "Display: O(n)" },
                             { name: "Append (Add to end)", description: "Adds a new node with data to the end of the linked list.", code: `# In SinglyLinkedList class:\ndef append(self, data):\n    new_node = Node(data)\n    if self.head is None:\n        self.head = new_node\n        return\n    last_node = self.head\n    while last_node.next:\n        last_node = last_node.next\n    last_node.next = new_node`, complexity: "O(n)" },
                             { name: "Prepend (Add to beginning)", description: "Adds a new node with data to the beginning of the linked list.", code: `# In SinglyLinkedList class:\ndef prepend(self, data):\n    new_node = Node(data)\n    new_node.next = self.head\n    self.head = new_node`, complexity: "O(1)" },
                             { name: "Delete Node (by value)", description: "Deletes the first occurrence of a node with the given data.", code: `# In SinglyLinkedList class:\ndef delete_node_by_value(self, key):\n    current_node = self.head\n    if current_node and current_node.data == key:\n        self.head = current_node.next\n        current_node = None # Optional: help GC\n        return True\n    prev_node = None\n    while current_node and current_node.data != key:\n        prev_node = current_node\n        current_node = current_node.next\n    if current_node is None:\n        return False # Key not found\n    prev_node.next = current_node.next\n    current_node = None # Optional: help GC\n    return True`, complexity: "O(n)" },
                             { name: "Search (by value)", description: "Checks if a value exists in the list.", code: `# In SinglyLinkedList class:\ndef search(self, key):\n    current_node = self.head\n    while current_node:\n        if current_node.data == key:\n            return True\n        current_node = current_node.next\n    return False`, complexity: "O(n)"},
                             { name: "Reverse Linked List", description: "Reverses the linked list iteratively.", code: `# In SinglyLinkedList class:\ndef reverse(self):\n    prev_node = None\n    current_node = self.head\n    while current_node:\n        next_node = current_node.next\n        current_node.next = prev_node\n        prev_node = current_node\n        current_node = next_node\n    self.head = prev_node`, complexity: "O(n)"},
                             { name: "Detect Loop (Floyd's Cycle Detection)", description: "Determines if a linked list has a cycle using two pointers (slow and fast).", code: `# In SinglyLinkedList class:\ndef has_loop(self):\n    slow_ptr = self.head\n    fast_ptr = self.head\n    while fast_ptr and fast_ptr.next:\n        slow_ptr = slow_ptr.next\n        fast_ptr = fast_ptr.next.next\n        if slow_ptr == fast_ptr:\n            return True\n    return False`, complexity: "O(n) time, O(1) space"}
                             // Add more: Insert at position, Delete at position, Get Nth node, Middle of LL
                        ]
                    },
                    {
                        id: "linked_lists_doubly",
                        title: "Doubly Linked List",
                        concept: "Each node has pointers to both the next and the previous node, allowing for bidirectional traversal and more efficient deletion of a known node if a pointer to it is available.",
                        operations: [
                            { name: "Node Class", description: "Node for Doubly Linked List.", code: `class DNode:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None\n        self.prev = None`, complexity: "-"},
                            { name: "DoublyLinkedList Class (Initialization & Display)", description: "Basic class with head and tail pointers.", code: `class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None # Optional, but useful\n\n    def display_forward(self):\n        elements = []\n        current = self.head\n        while current:\n            elements.append(str(current.data))\n            current = current.next\n        print(" <-> ".join(elements) if elements else "List is empty")\n\n    def display_backward(self):\n        elements = []\n        current = self.tail\n        while current:\n            elements.append(str(current.data))\n            current = current.prev\n        print(" <-> ".join(elements) if elements else "List is empty")`, complexity:"Display: O(n)"}
                            // Add: append, prepend, insert_after, insert_before, delete_node, search etc.
                        ]
                    },
                    {
                        id: "stacks_impl",
                        title: "Stack (LIFO)",
                        concept: "A Last-In, First-Out (LIFO) data structure. Python lists can easily simulate stacks (`append` for push, `pop` without index for pop). A custom implementation helps understand mechanics.",
                        operations: [
                            { name: "Stack using Python List", description: "Demonstrating stack operations using Python's list methods.", code: `stack_list = []\n# Push\nstack_list.append(10)\nstack_list.append(20) # stack_list: [10, 20]\n# Pop\nitem = stack_list.pop() # item: 20, stack_list: [10]\n# Peek (top element)\ntop_element = stack_list[-1] if stack_list else None # top_element: 10\n# Is Empty\nis_empty = not stack_list`, complexity: "Push (append): O(1) amortized, Pop: O(1), Peek: O(1), IsEmpty: O(1)" },
                            { name: "Custom Stack (using Linked List)", description: "Implementing a stack with its own Node and Stack classes.", code: `class StackNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass Stack:\n    def __init__(self):\n        self.top = None\n        self._size = 0\n\n    def push(self, data):\n        new_node = StackNode(data)\n        new_node.next = self.top\n        self.top = new_node\n        self._size += 1\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError("pop from empty stack")\n        popped_node = self.top\n        self.top = self.top.next\n        self._size -= 1\n        return popped_node.data\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError("peek from empty stack")\n        return self.top.data\n\n    def is_empty(self):\n        return self._size == 0\n\n    def size(self):\n        return self._size`, complexity: "All operations: O(1)"},
                            { name: "Application: Balanced Parentheses", description: "Using a stack to check if an expression has balanced parentheses ( (), [], {} ).", code: `def is_balanced(expression):\n    stack = []\n    mapping = {")": "(", "}": "{", "]": "["}\n    for char in expression:\n        if char in "([{":\n            stack.append(char)\n        elif char in ")]}":\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n    return not stack\n# is_balanced("{[()]}") -> True`, complexity: "O(n)"},
                            { name: "Application: Next Greater Element", description: "Find the next greater element for each element in an array.", code: `# Refer to Stack based solutions for NGE` , complexity: "O(n)"},
                            { name: "Application: Min Stack", description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.", code: `# Implement a MinStack class with an auxiliary stack to track minimums`, complexity: "All O(1)"}
                        ]
                    },
                    {
                        id: "queues_impl",
                        title: "Queue (FIFO)",
                        concept: "A First-In, First-Out (FIFO) data structure. `collections.deque` is highly efficient for implementing queues in Python. Custom implementations can be done with linked lists.",
                        operations: [
                            { name: "Queue using collections.deque", description: "Preferred way in Python.", code: `from collections import deque\n\nmy_queue = deque()\n# Enqueue\nmy_queue.append(10) # deque([10])\nmy_queue.append(20) # deque([10, 20])\n# Dequeue\nitem = my_queue.popleft() # item: 10, my_queue: deque([20])\n# Peek (front element)\nfront = my_queue[0] if my_queue else None # front: 20\n# Is Empty\nis_empty = not my_queue`, complexity: "Enqueue (append): O(1), Dequeue (popleft): O(1), Peek: O(1)"},
                            { name: "Custom Queue (using Linked List)", description: "Implementation with head and tail pointers for O(1) enqueue/dequeue.", code: `# Similar to StackNode, QueueNode has data and next\n# Queue class has front and rear pointers\nclass QueueNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self._size = 0\n\n    def enqueue(self, data):\n        new_node = QueueNode(data)\n        if self.rear is None: # Queue is empty\n            self.front = self.rear = new_node\n        else:\n            self.rear.next = new_node\n            self.rear = new_node\n        self._size += 1\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError("dequeue from empty queue")\n        item = self.front.data\n        self.front = self.front.next\n        if self.front is None: # Queue became empty\n            self.rear = None\n        self._size -= 1\n        return item\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError("peek from empty queue")\n        return self.front.data\n\n    def is_empty(self):\n        return self._size == 0\n\n    def size(self):\n        return self._size`, complexity: "All operations: O(1)" },
                            { name: "Application: Queue using Two Stacks", description: "Implementing a queue's FIFO behavior using two LIFO stacks.", code: `# Implement a QueueWithStacks class`, complexity: "Enqueue: O(1), Dequeue: O(n) worst case, O(1) amortized"}
                        ]
                    },
                    {
                        id: "priority_queues_heapq",
                        title: "Priority Queue (Min-Heap with heapq)",
                        concept: "A queue where each element has a priority, and elements with higher priority are dequeued before lower priority. Python's `heapq` module provides min-heap implementation, which can be used for priority queues (store -priority for max-heap behavior or tuples like (priority, item)).",
                        operations: [
                            { name: "Using heapq for Min-Priority Queue", description: "Basic operations with Python's heapq.", code: `import heapq\n\npq = [] # A simple list acts as the heap\n\nheapq.heappush(pq, (5, 'task1')) # (priority, item)\nheapq.heappush(pq, (1, 'task2'))\nheapq.heappush(pq, (3, 'task3'))\n# pq is now heapified: [(1, 'task2'), (5, 'task1'), (3, 'task3')] (internal order)\n\n# Get smallest (highest priority)\nhighest_priority_task = heapq.heappop(pq) # (1, 'task2')\n\n# Build heap from existing list\nitems = [(4,'a'),(2,'b'),(6,'c')]\nheapq.heapify(items) # items is now a heap`, complexity: "heappush: O(log n), heappop: O(log n), heapify: O(n)" },
                            { name: "Application: K Largest/Smallest Elements", description: "Finding the K largest or smallest elements in a collection using a heap.", code: `# For K smallest: maintain a max-heap of size K\n# For K largest: maintain a min-heap of size K`, complexity: "O(N log K)"}
                        ]
                    },
                    {
                        id: "hash_tables_impl",
                        title: "Hash Table / Hash Map (Custom Implementation)",
                        concept: "Implementing a hash table from scratch using an array (buckets) and a hash function to understand collision resolution (e.g., chaining with linked lists) and resizing. Python's `dict` is a highly optimized built-in hash map.",
                        operations: [
                             { name: "Basic Structure & Hash Function", description: "Class with buckets (list of lists/linked lists for chaining) and a simple hash function.", code: `class HashTable:\n    def __init__(self, size=10):\n        self.size = size\n        self.buckets = [[] for _ in range(self.size)] # Chaining\n\n    def _hash_function(self, key):\n        # Simple modulo hash, ensure key is hashable (e.g. string, int)\n        return hash(key) % self.size`, complexity: "Hash function: O(len(key)) for strings, O(1) for int"},
                             { name: "Put (Insert/Update)", description: "Adding a key-value pair, handling collisions by appending to the chain.", code: `# In HashTable class:\ndef put(self, key, value):\n    hash_index = self._hash_function(key)\n    bucket = self.buckets[hash_index]\n    for i, (k, v) in enumerate(bucket):\n        if k == key:\n            bucket[i] = (key, value) # Update existing key\n            return\n    bucket.append((key, value)) # Add new key-value pair`, complexity: "Average: O(1+L) (L=load factor), Worst: O(n)"},
                             { name: "Get (Search)", description: "Retrieving a value by key.", code: `# In HashTable class:\ndef get(self, key):\n    hash_index = self._hash_function(key)\n    bucket = self.buckets[hash_index]\n    for k, v in bucket:\n        if k == key:\n            return v\n    raise KeyError(f"Key '{key}' not found")`, complexity: "Average: O(1+L), Worst: O(n)"},
                             { name: "Delete", description: "Removing a key-value pair.", code: `# In HashTable class:\ndef delete(self, key):\n    hash_index = self._hash_function(key)\n    bucket = self.buckets[hash_index]\n    for i, (k, v) in enumerate(bucket):\n        if k == key:\n            del bucket[i]\n            return\n    raise KeyError(f"Key '{key}' not found")`, complexity: "Average: O(1+L), Worst: O(n)"}
                             // Add: Rehashing/Resizing strategy.
                        ]
                    }
                ]
            },
            // --- CATEGORY: Trees ---
            {
                category: "Trees",
                categoryId: "trees",
                icon: "fas fa-sitemap",
                description: "Hierarchical data structures composed of nodes. Includes various types like Binary Trees, BSTs, Heaps, Tries, etc., each with specific properties and use cases.",
                subTopics: [
                    {
                        id: "tree_terminology",
                        title: "Tree Terminology",
                        concept: "Basic concepts: Root, Node, Edge, Parent, Child, Sibling, Leaf, Internal Node, Subtree, Height of Node/Tree, Depth of Node, Degree of Node/Tree, Path, Forest.",
                        operations: [ { name: "Definitions", description: "Visual examples and explanations of each term.", code: `# Conceptual, no specific code for definitions themselves.`, complexity: "-"} ]
                    },
                    {
                        id: "binary_tree",
                        title: "Binary Tree",
                        concept: "A tree where each node has at most two children, referred to as the left child and the right child. Used as a basis for more specialized tree structures.",
                        operations: [
                            { name: "Node Class & Basic Tree Structure", description: "Python class for a tree node and optionally a BinaryTree class.", code: `class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None`, complexity: "-"},
                            { name: "In-order Traversal (LNR)", description: "Visits left subtree, then node, then right subtree.", code: `def inorder_traversal(node):\n    if node:\n        inorder_traversal(node.left)\n        print(node.value, end=' ')\n        inorder_traversal(node.right)`, complexity: "O(n)"},
                            { name: "Pre-order Traversal (NLR)", description: "Visits node, then left subtree, then right subtree.", code: `def preorder_traversal(node):\n    if node:\n        print(node.value, end=' ')\n        preorder_traversal(node.left)\n        preorder_traversal(node.right)`, complexity: "O(n)"},
                            { name: "Post-order Traversal (LRN)", description: "Visits left subtree, then right subtree, then node.", code: `def postorder_traversal(node):\n    if node:\n        postorder_traversal(node.left)\n        postorder_traversal(node.right)\n        print(node.value, end=' ')`, complexity: "O(n)"},
                            { name: "Level-order Traversal (BFS)", description: "Visits nodes level by level, from left to right. Uses a queue.", code: `from collections import deque\ndef levelorder_traversal(root):\n    if not root: return\n    q = deque([root])\n    while q:\n        node = q.popleft()\n        print(node.value, end=' ')\n        if node.left: q.append(node.left)\n        if node.right: q.append(node.right)`, complexity: "O(n) time, O(W) space (W=max width)"},
                            { name: "Height/Depth of Tree", description: "The number of edges on the longest path from the root to a leaf (height), or from root to a node (depth).", code: `def height(node):\n    if node is None: return -1 # or 0 for node count\n    return 1 + max(height(node.left), height(node.right))`, complexity: "O(n)"},
                            { name: "Diameter of Tree", description: "The longest path between any two nodes in a tree. This path may or may not pass through the root.", code: `# Recursive solution, often involves calculating height simultaneously.`, complexity: "O(n) or O(n^2) if height is recalculated"}
                        ]
                    },
                    {
                        id: "binary_search_tree_bst",
                        title: "Binary Search Tree (BST)",
                        concept: "A binary tree where each node's key is greater than all keys in its left subtree and less than (or equal to, depending on convention) all keys in its right subtree. Enables efficient average-case search, insert, delete.",
                        operations: [
                            { name: "Insert", description: "Adding a new key while maintaining BST properties.", code: `# Refer to earlier BST insert code.`, complexity: "Average: O(log n), Worst: O(n)"},
                            { name: "Search", description: "Finding a key in the BST.", code: `# Refer to earlier BST search code.`, complexity: "Average: O(log n), Worst: O(n)"},
                            { name: "Delete Node", description: "Removing a node while maintaining BST properties. Handles cases: node is leaf, node has one child, node has two children (replace with inorder successor/predecessor).", code: `# Complex, requires finding successor/predecessor.`, complexity: "Average: O(log n), Worst: O(n)"},
                            { name: "Find Min/Max Key", description: "Finding the minimum (leftmost) or maximum (rightmost) key.", code: `def find_min(node):\n    current = node\n    while current and current.left:\n        current = current.left\n    return current.value if current else None`, complexity: "Average: O(log n), Worst: O(n)"},
                            { name: "Validate BST", description: "Check if a given binary tree is a valid BST (maintaining min/max range for subtrees).", code: `def is_valid_bst(node, min_val=float('-inf'), max_val=float('inf')):\n    if node is None: return True\n    if not (min_val < node.value < max_val):\n        return False\n    return (is_valid_bst(node.left, min_val, node.value) and \n            is_valid_bst(node.right, node.value, max_val))`, complexity: "O(n)"},
                            { name: "Lowest Common Ancestor (LCA) in BST", description: "Finding the lowest common ancestor of two given nodes in a BST.", code: `def lca_bst(root, p_val, q_val):\n    # Assuming p_val and q_val exist and p_val < q_val\n    # Adjust if order is not guaranteed or existence is not.\n    current = root\n    while current:\n        if p_val < current.value and q_val < current.value:\n            current = current.left\n        elif p_val > current.value and q_val > current.value:\n            current = current.right\n        else: # Either one is current, or they are on opposite sides\n            return current\n    return None # Should not happen if p & q exist`, complexity: "O(h) where h is height"}
                        ]
                    },
                    {
                        id: "balanced_bst_avl",
                        title: "AVL Tree (Self-Balancing BST)",
                        concept: "A self-balancing BST where the height difference between left and right subtrees (balance factor) is at most 1 for every node. Rotations (LL, RR, LR, RL) are performed to maintain balance upon insertions/deletions, ensuring O(log n) for all major operations.",
                        operations: [
                            { name: "Node Class (with height & balance factor)", description: "...", code: "..." },
                            { name: "Rotations (Left, Right)", description: "Core operations to rebalance the tree.", code: "..." },
                            { name: "Insert with Rotations", description: "...", code: "..." },
                            { name: "Delete with Rotations (Conceptual)", description: "...", code: "..." }
                        ]
                    },
                    {
                        id: "heap_data_structure",
                        title: "Heap (Min-Heap, Max-Heap)",
                        concept: "A specialized tree-based (usually binary) data structure that satisfies the heap property: in a min-heap, for any given node C, if P is a parent of C, then key(P) <= key(C). Max-heap is analogous. Often implemented using arrays for efficiency. Python's `heapq` is a min-heap.",
                        operations: [
                            { name: "Heapify (Up/Down)", description: "Operations to maintain heap property after insertion or deletion.", code: `# Implement _heapify_up and _heapify_down for array-based heap.`},
                            { name: "Insert (heappush)", description: "Adding an element and maintaining heap property.", code: `# Show array-based insertion or use heapq.heappush`},
                            { name: "Extract Min/Max (heappop)", description: "Removing the root (min/max element) and re-heapifying.", code: `# Show array-based extraction or use heapq.heappop`},
                            { name: "Build Heap (from array)", description: "Converting an arbitrary array into a heap in O(n) time.", code: `# Show array-based build_heap or use heapq.heapify`},
                            { name: "Peek (get Min/Max)", description: "Viewing the root element without removing it.", code: `# For array-based heap, arr[0]`},
                            { name: "Heapsort Application", description: "Using a heap to sort an array.", code: `# Build max-heap, then repeatedly extract max.`}
                        ]
                    },
                    {
                        id: "trie_prefix_tree",
                        title: "Trie (Prefix Tree)",
                        concept: "A tree-like data structure where nodes store characters of a string. Paths from the root to a node represent prefixes. Efficient for storing and retrieving strings, auto-completion, and spell checking.",
                        operations: [
                            { name: "TrieNode Class", description: "Structure of a Trie node (children dictionary, end_of_word flag).", code: `class TrieNode:\n    def __init__(self):\n        self.children = {} # char -> TrieNode\n        self.is_end_of_word = False`},
                            { name: "Trie Class (Insert Word)", description: "Inserting a word into the Trie.", code: `class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True`},
                            { name: "Search Word", description: "Checking if a complete word exists in the Trie.", code: `# In Trie class:\ndef search(self, word):\n    node = self.root\n    for char in word:\n        if char not in node.children:\n            return False\n        node = node.children[char]\n    return node.is_end_of_word`},
                            { name: "Search Prefix (startsWith)", description: "Checking if any word starts with a given prefix.", code: `# In Trie class:\ndef starts_with(self, prefix):\n    node = self.root\n    for char in prefix:\n        if char not in node.children:\n            return False\n        node = node.children[char]\n    return True`}
                            // Add: Delete word (more complex due to shared prefixes).
                        ]
                    }
                    // Other tree topics (B-Tree conceptual)
                ]
            },
            // --- CATEGORY: Graphs ---
            {
                category: "Graphs",
                categoryId: "graphs",
                icon: "fas fa-project-diagram",
                description: "Data structures representing relationships between pairs of objects (vertices/nodes connected by edges). Can be directed/undirected, weighted/unweighted.",
                subTopics: [
                    {
                        id: "graph_terminology",
                        title: "Graph Terminology & Types",
                        concept: "Vertex/Node, Edge, Directed vs. Undirected, Weighted vs. Unweighted, Degree (In-degree, Out-degree), Path, Cycle, Connected Components, Adjacency List, Adjacency Matrix, Self-loop, Parallel edges, Simple graph, Multigraph, Complete graph, Bipartite graph, DAG (Directed Acyclic Graph).",
                        operations: [ { name: "Definitions", description: "Visual examples and explanations.", code: `# Conceptual.`, complexity: "-"} ]
                    },
                    {
                        id: "graph_representation",
                        title: "Graph Representation in Python",
                        concept: "Implementing graphs using Adjacency Lists (dictionary of lists/sets for unweighted, or dict of dicts/tuples for weighted) and Adjacency Matrix (2D array). Pros and cons: space complexity, ease of adding/removing edges, checking for an edge.",
                        operations: [
                            { name: "Adjacency List", description: "Using a dictionary where keys are vertices and values are lists/sets of adjacent vertices.", code: `graph_adj_list = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n# For weighted: graph_adj_list_weighted = {'A': {'B':5, 'C':2}}`, complexity: "Space: O(V+E)"},
                            { name: "Adjacency Matrix", description: "Using a VxV matrix where matrix[i][j] is 1 (or weight) if there's an edge from vertex i to j, else 0 (or infinity).", code: `vertices = ['A', 'B', 'C']\nidx_map = {v: i for i, v in enumerate(vertices)}\ngraph_adj_matrix = [[0]*len(vertices) for _ in range(len(vertices))]\ngraph_adj_matrix[idx_map['A']][idx_map['B']] = 1 # Edge A-B`, complexity: "Space: O(V^2)"},
                            { name: "Graph Class (Add Vertex/Edge)", description: "A simple Graph class demonstrating adding vertices and edges for an adjacency list representation.", code: `class Graph:\n    def __init__(self):\n        self.adj_list = {}\n\n    def add_vertex(self, vertex):\n        if vertex not in self.adj_list:\n            self.adj_list[vertex] = []\n\n    def add_edge(self, v1, v2, directed=False):\n        self.add_vertex(v1) # Ensure vertices exist\n        self.add_vertex(v2)\n        self.adj_list[v1].append(v2)\n        if not directed:\n            self.adj_list[v2].append(v1) # For undirected`, complexity: "Add Vertex: O(1) avg, Add Edge: O(1) avg"}
                        ]
                    },
                    {
                        id: "graph_traversal_bfs",
                        title: "Breadth-First Search (BFS)",
                        concept: "Algorithm for traversing or searching tree or graph data structures. Explores neighbor nodes first (layer by layer) before moving to the next level neighbors. Uses a queue. Finds shortest path in unweighted graphs.",
                        operations: [
                            { name: "BFS Implementation", description: "Python implementation using adjacency list and `collections.deque` as a queue.", code: `from collections import deque\n\ndef bfs(graph, start_node):\n    visited = set()\n    queue = deque([start_node])\n    visited.add(start_node)\n    traversal_order = []\n\n    while queue:\n        vertex = queue.popleft()\n        traversal_order.append(vertex)\n        for neighbor in graph.get(vertex, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return traversal_order`, complexity: "O(V+E)" }
                            // Applications: Shortest path (unweighted), connected components, cycle detection (undirected).
                        ]
                    },
                    {
                        id: "graph_traversal_dfs",
                        title: "Depth-First Search (DFS)",
                        concept: "Algorithm for traversing or searching tree or graph data structures. Explores as far as possible along each branch before backtracking. Uses a stack (implicitly via recursion or explicitly).",
                        operations: [
                            { name: "DFS Implementation (Recursive)", description: "Recursive Python implementation.", code: `def dfs_recursive(graph, start_node, visited=None, traversal_order=None):\n    if visited is None: visited = set()\n    if traversal_order is None: traversal_order = []\n\n    visited.add(start_node)\n    traversal_order.append(start_node)\n\n    for neighbor in graph.get(start_node, []):\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited, traversal_order)\n    return traversal_order`, complexity: "O(V+E)"},
                            { name: "DFS Implementation (Iterative with Stack)", description: "Iterative Python implementation using an explicit stack.", code: `def dfs_iterative(graph, start_node):\n    visited = set()\n    stack = [start_node]\n    traversal_order = []\n\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            traversal_order.append(vertex)\n            # Add unvisited neighbors in reverse order to process them in 'natural' order\n            for neighbor in reversed(graph.get(vertex, [])):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    return traversal_order`, complexity: "O(V+E)"}
                            // Applications: Cycle detection, topological sort, path finding, connected components.
                        ]
                    },
                    {
                        id: "shortest_path_dijkstra",
                        title: "Dijkstra's Algorithm (Single Source Shortest Path)",
                        concept: "Finds the shortest paths from a single source vertex to all other vertices in a weighted graph with non-negative edge weights. Uses a priority queue to greedily select the closest unvisited vertex.",
                        operations: [
                            { name: "Dijkstra's Implementation", description: "Python implementation using adjacency list (with weights) and `heapq` as a min-priority queue.", code: `import heapq\n\ndef dijkstra(graph, start_node):\n    # graph format: {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, ...}\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start_node] = 0\n    priority_queue = [(0, start_node)] # (distance, vertex)\n\n    while priority_queue:\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph.get(current_vertex, {}).items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return distances`, complexity: "O(E log V) or O((V+E)logV) with adjacency list and binary heap." }
                        ]
                    },
                    {
                        id: "mst_prims_kruskals",
                        title: "Minimum Spanning Tree (MST) - Prim's & Kruskal's",
                        concept: "A Minimum Spanning Tree (MST) of a connected, undirected graph is a subgraph that connects all vertices with the minimum possible total edge weight. Prim's and Kruskal's are two common greedy algorithms to find MSTs.",
                        operations: [
                            { name: "Prim's Algorithm", description: "Grows the MST from a starting vertex, adding the cheapest edge connecting a vertex in MST to one outside. Uses a priority queue.", code: `# Implementation details...`, complexity: "O(E log V)" },
                            { name: "Kruskal's Algorithm", description: "Sorts all edges by weight and adds edges one by one if they don't form a cycle (checked using Disjoint Set Union - DSU).", code: `# Implementation details with DSU...`, complexity: "O(E log E) or O(E log V)" }
                        ]
                    },
                    {
                        id: "topological_sort",
                        title: "Topological Sort (Directed Acyclic Graphs - DAGs)",
                        concept: "Linear ordering of vertices such that for every directed edge UV from vertex U to vertex V, U comes before V in the ordering. A graph must be a DAG to have a topological sort. Used for scheduling tasks with dependencies, course prerequisites, etc.",
                        operations: [
                            { name: "Kahn's Algorithm (BFS-based)", description: "Uses in-degrees of nodes. Add nodes with in-degree 0 to a queue. Process nodes from queue, decrement in-degrees of neighbors, add new 0-in-degree neighbors to queue.", code: `from collections import deque\n\ndef kahn_topological_sort(graph):\n    # graph: adjacency list like {'A': ['C'], 'B': ['C', 'D'], 'C': ['E'], ...}\n    # First, calculate in-degrees for all nodes\n    in_degree = {u: 0 for u in graph}\n    adj = {u: [] for u in graph} # Store adjacency for easier iteration\n    for u in graph:\n        for v in graph[u]:\n            if v not in in_degree: in_degree[v] = 0 # ensure all nodes are in in_degree\n            if u not in adj: adj[u] = []\n            adj[u].append(v)\n            in_degree[v] += 1\n\n    queue = deque([u for u in in_degree if in_degree[u] == 0])\n    topo_order = []\n\n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        for v in adj.get(u, []):\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n\n    if len(topo_order) == len(in_degree): # Check for cycle\n        return topo_order\n    else:\n        return [] # Graph has a cycle`, complexity: "O(V+E)" },
                            { name: "DFS-based Algorithm", description: "Perform DFS. The topological sort is the reverse of the post-order traversal (finishing times).", code: `# Implementation...`, complexity: "O(V+E)" }
                        ]
                    },
                     {
                        id: "cycle_detection_graph",
                        title: "Cycle Detection in Graphs",
                        concept: "Algorithms to detect if a graph contains cycles. Different approaches for directed and undirected graphs.",
                        operations: [
                            { name: "Undirected Graph (using DFS)", description: "Keep track of visited nodes and the parent in DFS traversal. If an adjacent node is visited and is not the parent, a cycle exists.", code: `# Implementation...`, complexity: "O(V+E)"},
                            { name: "Directed Graph (using DFS)", description: "Maintain three sets/states for nodes: unvisited, visiting (in current recursion stack), visited. If DFS encounters a node in 'visiting' state, a back edge (cycle) is found.", code: `# Implementation...`, complexity: "O(V+E)"},
                            { name: "Undirected Graph (using DSU)", description: "Iterate through edges. For an edge (u,v), if find(u) == find(v), a cycle exists. Otherwise, union(u,v).", code: `# Implementation with DSU...`, complexity: "Nearly O(E * alpha(V)) with path compression and union by rank/size"}
                        ]
                    }
                    // Add: Bellman-Ford, Floyd-Warshall (All-pairs shortest path), SCC, Max Flow (conceptual)
                ]
            },
            // --- CATEGORY: Sorting Algorithms ---
            {
                category: "Sorting Algorithms",
                categoryId: "sorting",
                icon: "fas fa-sort-amount-down",
                description: "Algorithms to arrange elements of a list or array in a specific order (e.g., ascending or descending). Understanding their mechanisms, time/space complexities, and stability is crucial.",
                subTopics: [
                    { id: "sorting_concepts", title: "Sorting Concepts", concept: "In-place vs. Out-of-place sorting, Stable vs. Unstable sorting, Comparison vs. Non-comparison sorts, Adaptive sorting.", operations: [{name:"Definitions", description:"Explanation of each concept.", code:"# Conceptual", complexity:"-"}] },
                    { id: "sorting_bubble", title: "Bubble Sort", concept: "Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Simple but inefficient for large lists.", operations: [ { name: "Implementation", description: "Standard and optimized (stops if no swaps in a pass).", code: `def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped: break # Optimization\n    return arr`, complexity: "Best: O(n), Avg/Worst: O(n^2). Stable. In-place." } ] },
                    { id: "sorting_selection", title: "Selection Sort", concept: "Repeatedly finds the minimum element from the unsorted part and puts it at the beginning of the sorted part. Simple but inefficient.", operations: [ { name: "Implementation", description: "", code: `def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr`, complexity: "O(n^2) always. In-place. Not stable by default (can be made stable)." } ] },
                    { id: "sorting_insertion", title: "Insertion Sort", concept: "Builds the final sorted array one item at a time by inserting each element from the input into its correct position in the already sorted part. Efficient for small datasets or nearly sorted data.", operations: [ { name: "Implementation", description: "", code: `def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n    return arr`, complexity: "Best: O(n), Avg/Worst: O(n^2). Stable. In-place." } ] },
                    { id: "sorting_merge", title: "Merge Sort", concept: "A divide-and-conquer algorithm. Divides the array into halves, sorts them recursively, and then merges the sorted halves. Always O(n log n) and stable.", operations: [ { name: "Implementation", description: "Recursive implementation with a merge helper function.", code: `def merge_sort(arr):\n    if len(arr) <= 1: return arr\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    # ... (merge logic)\n    merged = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i]); i += 1\n        else:\n            merged.append(right[j]); j += 1\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged`, complexity: "O(n log n) always. Stable. Space: O(n) (out-of-place)." } ] },
                    { id: "sorting_quick", title: "Quick Sort", concept: "A divide-and-conquer algorithm. Picks a 'pivot' element and partitions the array around the pivot (elements smaller than pivot to its left, larger to its right). Sorts subarrays recursively. Fast on average but O(n^2) worst case.", operations: [ { name: "Implementation (Lomuto/Hoare partition)", description: "Recursive implementation. Discuss pivot selection strategies.", code: `# Lomuto partition example\ndef quick_sort_lomuto(arr, low, high):\n    if low < high:\n        pi = partition_lomuto(arr, low, high)\n        quick_sort_lomuto(arr, low, pi - 1)\n        quick_sort_lomuto(arr, pi + 1, high)\n# ... (partition_lomuto logic)`, complexity: "Avg: O(n log n), Worst: O(n^2). Not stable by default. Space: O(log n) to O(n) (recursion stack)." } ] },
                    { id: "sorting_heap", title: "Heap Sort", concept: "Comparison-based sorting technique based on a Binary Heap data structure. First builds a max-heap (or min-heap), then repeatedly extracts the root element and places it at the end of the array, reducing heap size.", operations: [ { name: "Implementation", description: "Using heapify operations.", code: `# Build max-heap, then swap root with last element & heapify root`, complexity: "O(n log n) always. In-place. Not stable." } ] },
                    { id: "sorting_counting", title: "Counting Sort", concept: "Non-comparison integer sorting algorithm. Operates by counting the number of objects that have each distinct key value. Efficient when the range of input data (k) is not significantly greater than the number of objects (n).", operations: [ { name: "Implementation", description: "", code: `def counting_sort(arr, max_val):\n    count = [0] * (max_val + 1)\n    output = [0] * len(arr)\n    for num in arr: count[num] += 1\n    for i in range(1, max_val + 1): count[i] += count[i-1]\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i]] - 1] = arr[i]\n        count[arr[i]] -= 1\n    return output`, complexity: "O(n+k). Stable. Space: O(n+k)." } ] },
                    { id: "sorting_radix", title: "Radix Sort", concept: "Non-comparison integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value (LSD or MSD). Uses a stable sort like counting sort as a subroutine.", operations: [ { name: "LSD Radix Sort Implementation", description: "", code: `# Uses counting sort for each digit`, complexity: "O(d*(n+b)) where d=digits, b=base (e.g.,10)." } ] }
                    // Timsort (conceptual) is already listed under list operations
                ]
            },
            // --- CATEGORY: Searching Algorithms ---
            {
                category: "Searching Algorithms",
                categoryId: "searching",
                icon: "fas fa-search",
                description: "Algorithms to find an item with specified properties among a collection of items. Efficiency heavily depends on how data is organized (e.g., sorted or not).",
                subTopics: [
                    { id: "searching_linear", title: "Linear Search", concept: "Sequentially checks each element of the list/array until a match is found or the entire collection has been searched. Simple but inefficient for large datasets.", operations: [ { name: "Implementation", description: "", code: `def linear_search(arr, target):\n    for i, val in enumerate(arr):\n        if val == target: return i\n    return -1 # Not found`, complexity: "Best: O(1), Avg/Worst: O(n)." } ] },
                    {
                        id: "searching_binary",
                        title: "Binary Search",
                        concept: "Efficiently finds an item in a *sorted* array by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half.",
                        operations: [
                            { name: "Iterative Implementation", description: "", code: `def binary_search_iterative(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target: return mid\n        elif arr[mid] < target: low = mid + 1\n        else: high = mid - 1\n    return -1`, complexity: "O(log n)" },
                            { name: "Recursive Implementation", description: "", code: `def binary_search_recursive(arr, target, low, high):\n    if low > high: return -1\n    mid = (low + high) // 2\n    if arr[mid] == target: return mid\n    elif arr[mid] < target: return binary_search_recursive(arr, target, mid + 1, high)\n    else: return binary_search_recursive(arr, target, low, mid - 1)`, complexity: "O(log n) time, O(log n) space (stack)" }
                        ]
                    },
                    {
                        id: "binary_search_variants_applications",
                        title: "Binary Search Variants & Applications",
                        concept: "Extending binary search to solve related problems like finding bounds, occurrences in rotated arrays, or searching on the 'answer space'.",
                        operations: [
                            { name: "Find First Occurrence", description: "Find the first index of a target in a sorted array with duplicates.", code: `# Modify binary search to continue searching left if target is found`, complexity: "O(log n)"},
                            { name: "Find Last Occurrence", description: "Find the last index of a target in a sorted array with duplicates.", code: `# Modify binary search to continue searching right if target is found`, complexity: "O(log n)"},
                            { name: "Count Occurrences", description: "Find first and last occurrence, then count = last - first + 1.", code: ``, complexity: "O(log n)"},
                            { name: "Find Lower Bound (bisect_left)", description: "Finds the first index `i` where `arr[i] >= target`.", code: `# Python's bisect.bisect_left or custom implementation`, complexity: "O(log n)"},
                            { name: "Find Upper Bound (bisect_right)", description: "Finds the first index `i` where `arr[i] > target`.", code: `# Python's bisect.bisect_right or custom implementation`, complexity: "O(log n)"},
                            { name: "Search in Rotated Sorted Array", description: "Searching for a target in a sorted array that has been rotated at some pivot.", code: `# Find pivot, then binary search in appropriate half, or modified BS`, complexity: "O(log n)"},
                            { name: "Binary Search on Answer Space", description: "Applying binary search to find an optimal value (the 'answer') within a monotonic search space defined by a check function. E.g., find minimum capacity to ship packages, allocate minimum number of pages.", code: `# Conceptual with example problem setup.`, complexity: "O(X * log K) where X is check func complexity, K is range of answers"}
                        ]
                    }
                    // Other conceptual search algorithms: Ternary, Jump, Interpolation, Exponential.
                ]
            },
            // --- CATEGORY: Algorithm Design Paradigms ---
            {
                category: "Algorithm Design Paradigms",
                categoryId: "algo_paradigms",
                icon: "fas fa-lightbulb",
                description: "General approaches or techniques for designing algorithms to solve problems, such as Divide and Conquer, Greedy, Dynamic Programming, and Backtracking. These provide a framework for tackling new and complex challenges.",
                subTopics: [
                    {
                        id: "paradigm_basic_recursion",
                        title: "Basic Recursion Principles & Examples",
                        concept: "Understanding the fundamentals of recursion: a function that calls itself. Key components are the base case(s) to stop recursion and the recursive step(s) that move towards the base case. The call stack manages recursive calls.",
                        operations: [
                            { name: "Factorial", description: "Calculating n! = n * (n-1) * ... * 1.", code: `def factorial(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    # Recursive step\n    return n * factorial(n-1)`, complexity: "O(n) time, O(n) space (call stack)" },
                            { name: "Fibonacci Sequence (Recursive)", description: "Calculating the n-th Fibonacci number (F(n) = F(n-1) + F(n-2)). This is a classic example but very inefficient due to redundant calculations if not memoized.", code: `def fibonacci_recursive(n):\n    # Base cases\n    if n <= 0: return 0\n    if n == 1: return 1\n    # Recursive step\n    return fibonacci_recursive(n-2) + fibonacci_recursive(n-1)`, complexity: "O(2^n) time (without memoization)" },
                            { name: "Sum of Array Elements (Recursive)", description: "Calculating sum of elements in an array using recursion.", code: `def sum_array_recursive(arr, index=0):\n    # Base case: if index reaches end of array\n    if index == len(arr):\n        return 0\n    # Recursive step: current element + sum of rest of array\n    return arr[index] + sum_array_recursive(arr, index + 1)`, complexity: "O(n) time, O(n) space (call stack)" },
                            { name: "String Reversal (Recursive)", description: "Reversing a string using recursion.", code: `def reverse_string_recursive(s):\n    # Base case: empty string or single character string\n    if len(s) <= 1:\n        return s\n    # Recursive step: last char + reverse of (string without last char)\n    return s[-1] + reverse_string_recursive(s[:-1])`, complexity: "O(n) time due to slicing, O(n) space (call stack)" },
                            { name: "Tower of Hanoi", description: "Classic recursive puzzle involving moving disks between three pegs with certain rules.", code: `def tower_of_hanoi(n, source_peg, auxiliary_peg, destination_peg):\n    if n == 1:\n        print(f"Move disk 1 from {source_peg} to {destination_peg}")\n        return\n    # Move n-1 disks from source to auxiliary, using destination as temp\n    tower_of_hanoi(n-1, source_peg, destination_peg, auxiliary_peg)\n    # Move the nth disk from source to destination\n    print(f"Move disk {n} from {source_peg} to {destination_peg}")\n    # Move the n-1 disks from auxiliary to destination, using source as temp\n    tower_of_hanoi(n-1, auxiliary_peg, source_peg, destination_peg)`, complexity: "O(2^n) time" }
                        ]
                    },
                    {
                        id: "paradigm_divide_conquer",
                        title: "Divide and Conquer",
                        concept: "An algorithmic paradigm that involves three steps: 1. **Divide:** Break the problem into smaller, independent subproblems of the same type. 2. **Conquer:** Solve the subproblems recursively. If subproblems are small enough, solve them directly (base case). 3. **Combine:** Combine the solutions of the subproblems to form the solution to the original problem.",
                        operations: [
                            { name: "Example: Merge Sort", description: "Divides array, sorts halves, merges sorted halves.", code: `# See Merge Sort under Sorting Algorithms`, complexity: "O(n log n)"},
                            { name: "Example: Quick Sort", description: "Partitions array around pivot, sorts subarrays.", code: `# See Quick Sort under Sorting Algorithms`, complexity: "O(n log n) average"},
                            { name: "Example: Binary Search", description: "Repeatedly divides search interval in half.", code: `# See Binary Search under Searching Algorithms`, complexity: "O(log n)"},
                            { name: "Example: Closest Pair of Points (Conceptual)", description: "Finds the pair of points with the smallest distance between them in a set of points.", code: `# Conceptual, more advanced implementation.`, complexity: "O(n log n)"},
                            { name: "Master Theorem (Conceptual)", description: "A theorem used to determine the asymptotic complexity of recurrence relations of the form T(n) = aT(n/b) + f(n), often arising in divide-and-conquer algorithms.", code: `# No code, explain the cases.`, complexity: "-"}
                        ]
                    },
                    {
                        id: "paradigm_greedy",
                        title: "Greedy Algorithms",
                        concept: "Makes the locally optimal choice at each step with the hope of finding a global optimum. It doesn't always yield the optimal solution for all problems, but is often efficient and can provide good approximations or exact solutions for certain classes of problems (e.g., problems with greedy choice property and optimal substructure).",
                        operations: [
                            { name: "Activity Selection Problem", description: "Select the maximum number of non-overlapping activities from a given set of activities, each with a start and finish time. Greedy choice: select the activity that finishes earliest.", code: `# Sort activities by finish time, then pick compatible ones.`, complexity: "O(n log n) due to sort"},
                            { name: "Fractional Knapsack", description: "Given items with weights and values, fill a knapsack of a fixed capacity to maximize total value. Fractions of items can be taken. Greedy choice: pick items with the highest value-per-unit-weight ratio.", code: `# Calculate ratios, sort by ratio, fill knapsack.`, complexity: "O(n log n) due to sort"},
                            { name: "Huffman Coding", description: "A lossless data compression algorithm. Greedy choice: repeatedly merge the two nodes with the lowest frequencies to build a prefix code tree.", code: `# Use min-priority queue to manage frequencies and build tree.`, complexity: "O(n log n)"},
                            { name: "Job Sequencing with Deadlines", description: "Given jobs with deadlines and profits, find a sequence of jobs to maximize total profit, assuming each job takes one unit of time. Greedy choice: sort jobs by profit, schedule job in latest possible free slot before its deadline.", code: `# Sort by profit, use DSU or array to find available slots.`, complexity: "O(n log n + n*alpha(n)) or O(n^2)"},
                            { name: "Minimum Number of Platforms Required", description: "Find the minimum number of platforms required for a railway/bus station so that no train/bus waits. Greedy: Sort arrivals and departures. Track platforms needed.", code: `# Sort arrival and departure times. Iterate through them.`, complexity: "O(n log n)"},
                            { name: "Dijkstra's Algorithm (Greedy Aspect)", description: "At each step, Dijkstra's greedily picks the unvisited vertex with the smallest known distance.", code: `# See Dijkstra's under Graphs`, complexity: "O(E log V)"},
                            { name: "Prim's/Kruskal's MST (Greedy Aspect)", description: "Both algorithms make greedy choices to build the MST.", code: `# See MST under Graphs`, complexity: "Varies"}
                        ]
                    },
                    {
                        id: "paradigm_dp",
                        title: "Dynamic Programming (DP)",
                        concept: "Solves complex problems by breaking them down into simpler, overlapping subproblems. It solves each subproblem only once and stores its solution (memoization or tabulation) to avoid redundant computations. Requires optimal substructure (optimal solution to problem contains optimal solutions to subproblems) and overlapping subproblems properties.",
                        operations: [
                            { name: "Fibonacci Sequence (DP)", description: "Calculating n-th Fibonacci using memoization (top-down) or tabulation (bottom-up).", code: `// Memoization\nmemo = {}\ndef fib_memo(n):\n    if n in memo: return memo[n]\n    if n <= 1: return n\n    memo[n] = fib_memo(n-1) + fib_memo(n-2)\n    return memo[n]\n\n// Tabulation\ndef fib_tab(n):\n    if n <= 1: return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]`, complexity: "O(n) time, O(n) space (memo/dp table or stack)"},
                            { name: "0/1 Knapsack Problem", description: "Given item weights and values, and a knapsack capacity, determine the items to include to maximize total value without exceeding capacity. Each item can either be included or not.", code: `# DP table dp[i][w] = max value using first i items with capacity w.`, complexity: "O(N*W) time, O(N*W) or O(W) space"},
                            { name: "Longest Common Subsequence (LCS)", description: "Find the longest subsequence common to two given sequences (strings or arrays).", code: `# DP table dp[i][j] = LCS length of X[:i] and Y[:j].`, complexity: "O(m*n) time, O(m*n) or O(min(m,n)) space"},
                            { name: "Longest Increasing Subsequence (LIS)", description: "Find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.", code: `# DP array dp[i] = LIS length ending at index i (O(n^2)), or Patience sorting based O(n log n).`, complexity: "O(n^2) or O(n log n)"},
                            { name: "Matrix Chain Multiplication", description: "Find the most efficient way (minimum number of scalar multiplications) to multiply a chain of matrices.", code: `# DP table dp[i][j] = min cost to multiply matrices Ai through Aj.`, complexity: "O(n^3)"},
                            { name: "Coin Change Problem (Min Coins / Number of Ways)", description: "Given coin denominations and a target amount, find minimum coins to make the amount, or number of ways to make the amount.", code: `# DP array dp[amount] = min coins / number of ways.`, complexity: "O(Amount*NumCoins)"},
                            { name: "Edit Distance (Levenshtein Distance)", description: "Minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another.", code: `# DP table dp[i][j] = edit distance between s1[:i] and s2[:j].`, complexity: "O(m*n)"}
                        ]
                    },
                    {
                        id: "paradigm_backtracking",
                        title: "Backtracking",
                        concept: "A general algorithmic technique that systematically searches for solutions to a problem by incrementally building candidates. If a candidate is found to not lead to a solution (or violates constraints), the algorithm 'backtracks' (discards the candidate) and tries a different path. It's a form of depth-first search on the state space.",
                        operations: [
                            { name: "Subsets / Power Set", description: "Generate all possible subsets of a given set of distinct integers.", code: `def subsets(nums):\n    result = []\n    def backtrack(start_index, current_subset):\n        result.append(list(current_subset)) # Add a copy\n        for i in range(start_index, len(nums)):\n            current_subset.append(nums[i])\n            backtrack(i + 1, current_subset)\n            current_subset.pop() # Backtrack\n    backtrack(0, [])\n    return result`, complexity: "O(N * 2^N)"},
                            { name: "Permutations", description: "Generate all possible orderings of a given set of distinct integers.", code: `def permutations(nums):\n    result = []\n    def backtrack(current_permutation, remaining_elements):\n        if not remaining_elements:\n            result.append(list(current_permutation))\n            return\n        for i in range(len(remaining_elements)):\n            # Choose\n            num = remaining_elements[i]\n            current_permutation.append(num)\n            # Explore\n            backtrack(current_permutation, remaining_elements[:i] + remaining_elements[i+1:])\n            # Unchoose (backtrack)\n            current_permutation.pop()\n    backtrack([], nums)\n    return result\n# Simpler with used array: backtrack(current_perm, nums, used_array)`, complexity: "O(N * N!)"},
                            { name: "N-Queens Problem", description: "Place N chess queens on an N×N chessboard such that no two queens threaten each other.", code: `# Backtrack by placing queens row by row, checking column and diagonal conflicts.`, complexity: "O(N!) roughly"},
                            { name: "Rat in a Maze", description: "Find a path for a rat to go from a source to a destination in a maze represented by a binary matrix.", code: `# Backtrack by trying all possible moves (Up, Down, Left, Right), marking visited cells.`, complexity: "Exponential"},
                            { name: "Sudoku Solver", description: "Fill a partially filled 9×9 Sudoku grid such that each column, each row, and each of the nine 3×3 subgrids contain all of the digits from 1 to 9.", code: `# Find empty cell, try numbers 1-9, if valid, recurse. If no solution, backtrack.`, complexity: "Exponential (9^m for m empty cells, but heavily pruned)"}
                        ]
                    }
                    // Conceptual: Branch & Bound, Randomized Algos
                ]
            },
            // --- CATEGORY: String Algorithms ---
            {
                category: "String Algorithms",
                categoryId: "string_algos",
                icon: "fas fa-spell-check",
                description: "Specialized algorithms for processing and analyzing strings, such as pattern matching (substring search), sequence alignment, and utilizing string-specific data structures.",
                subTopics: [
                    { id: "string_matching_naive", title: "Naive Pattern Searching", concept: "The simplest method: slide the pattern one by one over the text and check for a match at each position.", operations: [ {name:"Implementation", description:"", code: `def naive_search(text, pattern):\n    n, m = len(text), len(pattern)\n    occurrences = []\n    for i in range(n - m + 1):\n        if text[i:i+m] == pattern:\n            occurrences.append(i)\n    return occurrences`, complexity: "O((n-m+1)*m) which is O(nm)"}] },
                    { id: "string_matching_kmp", title: "Knuth-Morris-Pratt (KMP) Algorithm", concept: "An efficient linear time pattern searching algorithm. It preprocesses the pattern to create an LPS (Longest Proper Prefix which is also Suffix) array. This array helps to skip characters when a mismatch occurs, avoiding redundant comparisons.", operations: [ { name: "LPS Array Computation", description: "", code: `# Compute lps array logic...`}, { name: "KMP Search", description: "", code: `# KMP search logic using lps array...`}, {name: "Overall Complexity", description:"", code:"", complexity: "O(n+m)"} ] },
                    { id: "string_matching_rabin_karp", title: "Rabin-Karp Algorithm", concept: "A pattern searching algorithm that uses hashing to find occurrences of a pattern in a text. It calculates hash values for the pattern and for substrings of the text (using a rolling hash for efficiency). If hashes match, it then verifies character by character.", operations: [ { name: "Rolling Hash Implementation", description: "", code: `# Rolling hash function, handling prime modulus.`}, {name:"Rabin-Karp Search", description: "", code: `# Search logic, handling spurious hits.`}, {name:"Overall Complexity", description:"", code:"", complexity: "Average: O(n+m), Worst: O(nm) (due to hash collisions)"} ] }
                    // Conceptual: Suffix Array & Suffix Tree (already in main structure)
                    // LCS and Edit Distance are already under DP, which is fine.
                ]
            },
            // --- CATEGORY: Bit Manipulation ---
            {
                category: "Bit Manipulation",
                categoryId: "bit_manipulation",
                icon: "fas fa-microchip",
                description: "Techniques for operating on data at the bit level (0s and 1s). These can lead to highly efficient solutions for certain problems by leveraging the underlying binary representation of numbers.",
                subTopics: [
                    {
                        id: "bit_ops_basics",
                        title: "Basic Bitwise Operators",
                        concept: "Understanding Python's bitwise operators: AND (`&`), OR (`|`), XOR (`^`), NOT (`~`), Left Shift (`<<`), Right Shift (`>>`). Their truth tables and effects on binary representations.",
                        operations: [
                            { name: "AND (&)", description: "Result bit is 1 if both corresponding bits are 1.", code: `a = 5 # 0101\nb = 3 # 0011\nresult = a & b # 0001 (1)`, complexity: "O(1)"},
                            { name: "OR (|)", description: "Result bit is 1 if at least one corresponding bit is 1.", code: `a = 5 # 0101\nb = 3 # 0011\nresult = a | b # 0111 (7)`, complexity: "O(1)"},
                            { name: "XOR (^)", description: "Result bit is 1 if corresponding bits are different.", code: `a = 5 # 0101\nb = 3 # 0011\nresult = a ^ b # 0110 (6)`, complexity: "O(1)"},
                            { name: "NOT (~)", description: "Inverts all bits. In Python, for integer `x`, `~x` is `-(x+1)` due to two's complement representation.", code: `a = 5 # 0101\nresult = ~a # -6 (in two's complement system for signed integers)`, complexity: "O(1)"},
                            { name: "Left Shift (<<)", description: "Shifts bits to the left, filling with zeros from the right. Equivalent to multiplying by 2^k.", code: `a = 5 # 0101\nresult = a << 1 # 1010 (10)\nresult2 = a << 2 # 10100 (20)`, complexity: "O(1)"},
                            { name: "Right Shift (>>)", description: "Shifts bits to the right. For positive numbers, fills with zeros from the left (arithmetic shift). Equivalent to floor dividing by 2^k.", code: `a = 10 # 1010\nresult = a >> 1 # 0101 (5)\nresult2 = a >> 2 # 0010 (2)`, complexity: "O(1)"}
                        ]
                    },
                    {
                        id: "bit_tricks_common",
                        title: "Common Bitwise Tricks & Techniques",
                        concept: "Leveraging bitwise operators to solve common problems efficiently or achieve specific manipulations.",
                        operations: [
                            { name: "Check if Even or Odd", description: "A number is even if its last bit is 0, odd if 1.", code: `def is_even(n):\n    return (n & 1) == 0\n# is_even(4) -> True, is_even(5) -> False`, complexity: "O(1)"},
                            { name: "Get i-th Bit", description: "Check if the i-th bit (0-indexed from right) is set.", code: `def get_bit(num, i):\n    return (num >> i) & 1\n# get_bit(5, 0) -> 1 (0101, 0th bit is 1)\n# get_bit(5, 1) -> 0 (0101, 1st bit is 0)`, complexity: "O(1)"},
                            { name: "Set i-th Bit", description: "Set the i-th bit to 1.", code: `def set_bit(num, i):\n    return num | (1 << i)\n# set_bit(4, 0) -> 5 (0100 -> 0101)`, complexity: "O(1)"},
                            { name: "Clear i-th Bit", description: "Set the i-th bit to 0.", code: `def clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask\n# clear_bit(5, 0) -> 4 (0101 -> 0100)`, complexity: "O(1)"},
                            { name: "Toggle i-th Bit", description: "Flip the i-th bit.", code: `def toggle_bit(num, i):\n    return num ^ (1 << i)\n# toggle_bit(5, 1) -> 7 (0101 -> 0111)`, complexity: "O(1)"},
                            { name: "Count Set Bits (Hamming Weight)", description: "Count the number of 1s in the binary representation of a number.", code: `def count_set_bits_kernighan(n):\n    count = 0\n    while n > 0:\n        n &= (n - 1) # Clears the least significant set bit\n        count += 1\n    return count\n# count_set_bits_kernighan(5) -> 2 (0101)\n# Python built-in: bin(n).count('1')`, complexity: "O(k) where k is number of set bits (Kernighan), or O(log n) for built-in." },
                            { name: "Check if Power of 2", description: "A positive number is a power of 2 if it has only one bit set.", code: `def is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0\n# is_power_of_two(8) -> True (1000), is_power_of_two(6) -> False (0110)`, complexity: "O(1)"},
                            { name: "Find Single Non-Repeating Element (among pairs)", description: "If all elements appear twice except one, XORing all elements gives the unique one.", code: `def find_single_number(nums):\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n# find_single_number([2,2,1,3,3]) -> 1`, complexity: "O(n)"},
                            { name: "Swap Two Numbers without Temp Variable", description: "Using XOR properties.", code: `a = 5; b = 10\na = a ^ b\nb = a ^ b # b becomes original a\na = a ^ b # a becomes original b`, complexity: "O(1)"}
                        ]
                    }
                    // Conceptual: Bitmasks for Set Representation, advanced problems.
                ]
            },
            // --- CATEGORY: Advanced & Specialized Topics --- (already mostly covered)
            {
                category: "Advanced Data Structures & Algorithms", // Renamed for clarity
                categoryId: "advanced_topics",
                icon: "fas fa-graduation-cap",
                description: "More complex algorithms and data structures, often used in competitive programming, specialized domains, or advanced system design.",
                subTopics: [
                    // DSU, Segment Tree, Fenwick Tree, Heavy-Light (conceptual), FFT (conceptual),
                    // Number Theory (conceptual), Computational Geometry (conceptual), Game Theory (conceptual)
                    // ... as previously defined, ensure they are distinct and avoid too much overlap with other categories if specific algos are already covered.
                    {
                        id: "advanced_dsu_union_find",
                        title: "Disjoint Set Union (DSU) / Union-Find",
                        concept: "A data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. It supports two primary operations: `find` (determine which subset an element belongs to, returning a representative/parent) and `union` (merge two subsets). Optimizations include path compression and union by rank/size for nearly constant time operations on average.",
                        operations: [
                            {name: "DSU Class Initialization", description:"Initializing parent and rank/size arrays.", code:`class DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n # or self.size = [1] * n\n\n    def find(self, i): # With path compression\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union_by_rank(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i] < self.rank[root_j]: self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]: self.parent[root_j] = root_i\n            else: self.parent[root_j] = root_i; self.rank[root_i] += 1\n            return True # Merged\n        return False # Already in same set`, complexity: "Find/Union: Amortized O(alpha(n)) - nearly constant"},
                            {name: "Application: Kruskal's MST", description:"Used to detect cycles when adding edges.", code:`# See Kruskal's under Graphs/MST`, complexity:"-"},
                            {name: "Application: Cycle Detection in Undirected Graph", description:"Detecting cycles efficiently.", code:`# See Cycle Detection under Graphs`, complexity:"-"}
                        ]
                    }
                    // Add more advanced topics like Segment Tree, Fenwick Tree if desired.
                    // For conceptual topics like FFT, Comp. Geometry, Game Theory - provide problem statements and algorithm names.
                ]
            }
        ];

        // --- DOM ELEMENTS ---
        const themeSwitcherBtn = document.getElementById('themeSwitcher');
        const dsaContainer = document.getElementById('dsaContainer');
        const currentYearSpan = document.getElementById('currentYear');
        const searchInput = document.getElementById('searchInput');

        // Modal DOM Elements
        const dsaTopicModal = document.getElementById('dsaTopicModal');
        const modalTopicTitleEl = document.getElementById('modalTopicTitle');
        const modalTopicBodyEl = document.getElementById('modalTopicBody');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- THEME SWITCHER LOGIC ---
        function setTheme(theme) {
            if(document.body.getAttribute('data-theme') === theme && themeSwitcherBtn.innerHTML !== '') return; // Avoid redundant sets if already set and icon is loaded

            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            if (theme === 'dark') {
                if(themeSwitcherBtn) themeSwitcherBtn.innerHTML = '<i class="fas fa-sun"></i>';
                if(themeSwitcherBtn) themeSwitcherBtn.title = "Switch to light mode";
            } else {
                if(themeSwitcherBtn) themeSwitcherBtn.innerHTML = '<i class="fas fa-moon"></i>';
                if(themeSwitcherBtn) themeSwitcherBtn.title = "Switch to dark mode";
            }
        }

        // --- RENDER DSA TOPICS ---
        function renderDSATopics() {
            if (!dsaContainer) {
                console.error("DSA Container not found!");
                return;
            }
            dsaContainer.innerHTML = ''; // Clear existing content

            dsaTopics.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.classList.add('dsa-category');
                categoryDiv.setAttribute('data-category-id', category.categoryId);

                let subTopicsHTML = '';
                if (category.subTopics && category.subTopics.length > 0) {
                    subTopicsHTML = category.subTopics.map(subTopic => `
                        <div class="sub-topic-item" data-subtopic-id="${subTopic.id}" data-category-id="${category.categoryId}">
                            <h3 class="sub-topic-title">${subTopic.title}</h3>
                        </div>
                    `).join('');
                }

                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <div class="category-title">
                            <i class="icon ${category.icon || 'fas fa-folder'}"></i>
                            <span>${category.category}</span>
                        </div>
                        <i class="fas fa-chevron-down category-toggle-icon"></i>
                    </div>
                    ${category.description ? `<p class="category-description">${category.description}</p>` : ''}
                    <div class="sub-topics-list">
                        ${subTopicsHTML}
                    </div>
                `;
                dsaContainer.appendChild(categoryDiv);
            });

            addEventListeners();
        }

        // --- EVENT LISTENERS ---
        function addEventListeners() {
            // Category Accordion
            document.querySelectorAll('.category-header').forEach(header => {
                header.addEventListener('click', () => {
                    const categoryDiv = header.closest('.dsa-category');
                    if(categoryDiv) categoryDiv.classList.toggle('active');
                });
            });

            // Sub-topic Click (Opens Modal)
            document.querySelectorAll('.sub-topic-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    event.stopPropagation(); 

                    const subTopicId = item.dataset.subtopicId;
                    const categoryId = item.dataset.categoryId;
                    
                    if (!categoryId) {
                        console.error("Category ID not found on sub-topic item:", item);
                        return;
                    }

                    const topicData = findSubTopicData(categoryId, subTopicId);
                    if (topicData && dsaTopicModal && modalTopicTitleEl && modalTopicBodyEl) {
                        modalTopicTitleEl.textContent = topicData.title;
                        renderSubTopicDetailIntoModal(modalTopicBodyEl, topicData);
                        dsaTopicModal.style.display = 'block';
                        document.body.style.overflow = 'hidden';

                        if (window.Prism) {
                           Prism.highlightAllUnder(modalTopicBodyEl);
                        }
                    } else {
                        if (!topicData) console.error("Topic data not found for:", categoryId, subTopicId);
                        if (!dsaTopicModal) console.error("DSA Topic Modal element not found");
                    }
                });
            });
        }
        
        function findSubTopicData(categoryId, subTopicId) {
            const category = dsaTopics.find(cat => cat.categoryId === categoryId);
            if (category && category.subTopics) {
                return category.subTopics.find(sub => sub.id === subTopicId);
            }
            return null;
        }

        function renderSubTopicDetailIntoModal(modalBodyElement, subTopicData) {
            let operationsHTML = '';
            if (subTopicData.operations && subTopicData.operations.length > 0) {
                operationsHTML = `
                    <h4>Operations / Examples:</h4>
                    <div class="operations-list">
                        ${subTopicData.operations.map(op => `
                            <div class="operation">
                                <h5>${op.name}</h5>
                                ${op.description ? `<p class="op-description">${op.description}</p>` : ''}
                                <pre><code class="language-python">${escapeHtml(op.code)}</code></pre>
                                ${op.complexity ? `<p class="op-complexity"><strong>Complexity:</strong> <code>${op.complexity}</code></p>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            modalBodyElement.innerHTML = `
                <h4>Concept</h4>
                <p>${subTopicData.concept || 'Concept details coming soon.'}</p>
                ${operationsHTML}
            `;
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // --- MODAL CLOSING LOGIC ---
        if(closeModalBtn && dsaTopicModal) { // Ensure elements exist
            closeModalBtn.addEventListener('click', () => {
                dsaTopicModal.style.display = 'none';
                document.body.style.overflow = 'auto';
            });

            window.addEventListener('click', (event) => {
                if (event.target === dsaTopicModal) {
                    dsaTopicModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
        
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && dsaTopicModal.style.display === 'block') {
                    dsaTopicModal.style.display = 'none';
                    document.body.style.overflow = 'auto';
                }
            });
        }


        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            const initialTheme = localStorage.getItem('theme') || 
                                 (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            setTheme(initialTheme); // Set theme first

            if(currentYearSpan) currentYearSpan.textContent = new Date().getFullYear();
            
            try {
                const rootStyle = getComputedStyle(document.documentElement);
                const secondaryColorValue = rootStyle.getPropertyValue('--secondary-color').trim();
                const rgbSecondary = secondaryColorValue.startsWith('#') ? hexToRgb(secondaryColorValue) : parseRgb(secondaryColorValue);
                if (rgbSecondary) {
                     document.documentElement.style.setProperty('--secondary-color-rgb', `${rgbSecondary.r}, ${rgbSecondary.g}, ${rgbSecondary.b}`);
                } else {
                    console.warn("Could not parse --secondary-color for RGBA shadow.");
                }

                const primaryColorValue = rootStyle.getPropertyValue('--primary-color').trim();
                const rgbPrimary = primaryColorValue.startsWith('#') ? hexToRgb(primaryColorValue) : parseRgb(primaryColorValue);
                if(rgbPrimary){
                    document.documentElement.style.setProperty('--primary-color-rgb', `${rgbPrimary.r}, ${rgbPrimary.g}, ${rgbPrimary.b}`);
                } else {
                     console.warn("Could not parse --primary-color for RGBA shadow.");
                }
            } catch (e) {
                console.error("Error setting up RGB CSS variables:", e);
            }

            renderDSATopics();
        });

        if(themeSwitcherBtn) {
            themeSwitcherBtn.addEventListener('click', () => {
                const newTheme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                setTheme(newTheme);
            });
        }
        
        // Helper functions for color conversion for box-shadow RGBA
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        function parseRgb(rgbString) { 
            const match = rgbString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            return match ? { r: parseInt(match[1]), g: parseInt(match[2]), b: parseInt(match[3])} : null;
        }

        // --- SEARCH FUNCTIONALITY ---
        if(searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                filterTopics(searchTerm);
            });
        }
        function filterTopics(searchTerm) {
            const allCategories = document.querySelectorAll('.dsa-category');
            allCategories.forEach(categoryElem => {
                const categoryTitle = categoryElem.querySelector('.category-title span').textContent.toLowerCase();
                const categoryDesc = categoryElem.querySelector('.category-description') ? categoryElem.querySelector('.category-description').textContent.toLowerCase() : '';
                let categoryMatches = categoryTitle.includes(searchTerm) || categoryDesc.includes(searchTerm);
                
                let hasVisibleSubTopic = false;
                const subTopicItems = categoryElem.querySelectorAll('.sub-topic-item');
                
                subTopicItems.forEach(subTopicElem => {
                    const subTopicTitle = subTopicElem.querySelector('.sub-topic-title').textContent.toLowerCase();
                    const subTopicData = findSubTopicData(categoryElem.dataset.categoryId, subTopicElem.dataset.subtopicId);
                    const concept = subTopicData?.concept?.toLowerCase() || '';
                    
                    const subTopicMatches = subTopicTitle.includes(searchTerm) || concept.includes(searchTerm);

                    if (subTopicMatches) {
                        subTopicElem.style.display = '';
                        hasVisibleSubTopic = true;
                    } else {
                        subTopicElem.style.display = 'none';
                    }
                });

                if (categoryMatches || hasVisibleSubTopic) {
                    categoryElem.style.display = '';
                    if (searchTerm && hasVisibleSubTopic && !categoryElem.classList.contains('active')) {
                        // Optional: auto-expand if a sub-topic matches. Consider UX.
                        // categoryElem.classList.add('active'); 
                    }
                } else {
                    categoryElem.style.display = 'none';
                }

                if (!searchTerm) { // If search is cleared
                    categoryElem.style.display = '';
                    subTopicItems.forEach(st => st.style.display = '');
                    // categoryElem.classList.remove('active'); // Optionally collapse all
                }
            });
        }
    </script>
</body>
</html>
